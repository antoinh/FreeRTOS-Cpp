<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FreeRTOS-Cpp: FreeRTOS::MessageBufferBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FreeRTOS-Cpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>FreeRTOS</b></li><li class="navelem"><a class="el" href="classFreeRTOS_1_1MessageBufferBase.html">MessageBufferBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classFreeRTOS_1_1MessageBufferBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FreeRTOS::MessageBufferBase Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class that provides the standard message buffer interface to <a class="el" href="classFreeRTOS_1_1MessageBuffer.html" title="Class that encapsulates the functionality of a FreeRTOS message buffer.">FreeRTOS::MessageBuffer</a> and <a class="el" href="classFreeRTOS_1_1StaticMessageBuffer.html" title="Class that encapsulates the functionality of a FreeRTOS message buffer.">FreeRTOS::StaticMessageBuffer</a>.  
 <a href="classFreeRTOS_1_1MessageBufferBase.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="MessageBuffer_8hpp_source.html">FreeRTOS/MessageBuffer.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FreeRTOS::MessageBufferBase:</div>
<div class="dyncontent">
<div class="center"><img src="classFreeRTOS_1_1MessageBufferBase__inherit__graph.png" border="0" usemap="#aFreeRTOS_1_1MessageBufferBase_inherit__map" alt="Inheritance graph"/></div>
<map name="aFreeRTOS_1_1MessageBufferBase_inherit__map" id="aFreeRTOS_1_1MessageBufferBase_inherit__map">
<area shape="rect" title="Base class that provides the standard message buffer interface to FreeRTOS::MessageBuffer and FreeRTO..." alt="" coords="115,5,336,32"/>
<area shape="rect" href="classFreeRTOS_1_1MessageBuffer.html" title="Class that encapsulates the functionality of a FreeRTOS message buffer." alt="" coords="5,80,195,107"/>
<area shape="rect" href="classFreeRTOS_1_1StaticMessageBuffer.html" title="Class that encapsulates the functionality of a FreeRTOS message buffer." alt="" coords="219,80,485,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af5916911446fc457c3ceb631deb32e74"><td class="memItemLeft" align="right" valign="top"><a id="af5916911446fc457c3ceb631deb32e74"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MessageBufferBase</b> (const <a class="el" href="classFreeRTOS_1_1MessageBufferBase.html">MessageBufferBase</a> &amp;)=delete</td></tr>
<tr class="separator:af5916911446fc457c3ceb631deb32e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785058497c6b7fb15256563ad312187e"><td class="memItemLeft" align="right" valign="top"><a id="a785058497c6b7fb15256563ad312187e"></a>
<a class="el" href="classFreeRTOS_1_1MessageBufferBase.html">MessageBufferBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classFreeRTOS_1_1MessageBufferBase.html">MessageBufferBase</a> &amp;)=delete</td></tr>
<tr class="separator:a785058497c6b7fb15256563ad312187e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95282112420e61271953947198f609e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#a95282112420e61271953947198f609e6">isValid</a> () const</td></tr>
<tr class="memdesc:a95282112420e61271953947198f609e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that checks if the underlying message buffer handle is not NULL. This should be used to ensure a message buffer has been created correctly.  <a href="classFreeRTOS_1_1MessageBufferBase.html#a95282112420e61271953947198f609e6">More...</a><br /></td></tr>
<tr class="separator:a95282112420e61271953947198f609e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14f4d52f5b4d90fd19524e6197f9547f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#a14f4d52f5b4d90fd19524e6197f9547f">send</a> (const void *data, const size_t length, const TickType_t ticksToWait=portMAX_DELAY) const</td></tr>
<tr class="memdesc:a14f4d52f5b4d90fd19524e6197f9547f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>size_t xMessageBufferSend( MessageBufferHandle_t xMessageBuffer, const void *pvTxData, size_t xDataLengthBytes, TickType_t xTicksToWait )</code>  <a href="classFreeRTOS_1_1MessageBufferBase.html#a14f4d52f5b4d90fd19524e6197f9547f">More...</a><br /></td></tr>
<tr class="separator:a14f4d52f5b4d90fd19524e6197f9547f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c01dca6f4fd0b969fb0596c53c8156"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#a37c01dca6f4fd0b969fb0596c53c8156">sendFromISR</a> (bool &amp;higherPriorityTaskWoken, const void *data, const size_t length) const</td></tr>
<tr class="memdesc:a37c01dca6f4fd0b969fb0596c53c8156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>size_t xMessageBufferSendFromISR( MessageBufferHandle_t xMessageBuffer, const void *pvTxData, size_t xDataLengthBytes, BaseType_t *pxHigherPriorityTaskWoken )</code>  <a href="classFreeRTOS_1_1MessageBufferBase.html#a37c01dca6f4fd0b969fb0596c53c8156">More...</a><br /></td></tr>
<tr class="separator:a37c01dca6f4fd0b969fb0596c53c8156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4674426cb93c270ddb4f9c707e08dbe"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#aa4674426cb93c270ddb4f9c707e08dbe">sendFromISR</a> (const void *data, const size_t length) const</td></tr>
<tr class="memdesc:aa4674426cb93c270ddb4f9c707e08dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>size_t xMessageBufferSendFromISR( MessageBufferHandle_t xMessageBuffer, const void *pvTxData, size_t xDataLengthBytes, BaseType_t *pxHigherPriorityTaskWoken )</code>  <a href="classFreeRTOS_1_1MessageBufferBase.html#aa4674426cb93c270ddb4f9c707e08dbe">More...</a><br /></td></tr>
<tr class="separator:aa4674426cb93c270ddb4f9c707e08dbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80533ab7f12e923b439539aa8f12e19d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#a80533ab7f12e923b439539aa8f12e19d">receive</a> (void *buffer, const size_t bufferLength, const TickType_t ticksToWait=portMAX_DELAY) const</td></tr>
<tr class="memdesc:a80533ab7f12e923b439539aa8f12e19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>size_t xMessageBufferReceive( MessageBufferHandle_t xMessageBuffer, void *pvRxData, size_t xBufferLengthBytes, TickType_t xTicksToWait )</code>  <a href="classFreeRTOS_1_1MessageBufferBase.html#a80533ab7f12e923b439539aa8f12e19d">More...</a><br /></td></tr>
<tr class="separator:a80533ab7f12e923b439539aa8f12e19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac42521e68f9ac6ca8344a238f9043d9e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#ac42521e68f9ac6ca8344a238f9043d9e">receiveFromISR</a> (bool &amp;higherPriorityTaskWoken, void *buffer, const size_t bufferLength) const</td></tr>
<tr class="memdesc:ac42521e68f9ac6ca8344a238f9043d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>size_t xMessageBufferReceiveFromISR( MessageBufferHandle_t xMessageBuffer, void *pvRxData, size_t xBufferLengthBytes, BaseType_t *pxHigherPriorityTaskWoken )</code>  <a href="classFreeRTOS_1_1MessageBufferBase.html#ac42521e68f9ac6ca8344a238f9043d9e">More...</a><br /></td></tr>
<tr class="separator:ac42521e68f9ac6ca8344a238f9043d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3858222ed39283a4179ed184c12ae949"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#a3858222ed39283a4179ed184c12ae949">receiveFromISR</a> (void *buffer, const size_t bufferLength) const</td></tr>
<tr class="memdesc:a3858222ed39283a4179ed184c12ae949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>size_t xMessageBufferReceiveFromISR( MessageBufferHandle_t xMessageBuffer, void *pvRxData, size_t xBufferLengthBytes, BaseType_t *pxHigherPriorityTaskWoken )</code>  <a href="classFreeRTOS_1_1MessageBufferBase.html#a3858222ed39283a4179ed184c12ae949">More...</a><br /></td></tr>
<tr class="separator:a3858222ed39283a4179ed184c12ae949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06abfa89f97fac22e97be9f00ea7b553"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#a06abfa89f97fac22e97be9f00ea7b553">spacesAvailable</a> () const</td></tr>
<tr class="memdesc:a06abfa89f97fac22e97be9f00ea7b553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>size_t xMessageBufferSpacesAvailable( MessageBufferHandle_t xMessageBuffer )</code>  <a href="classFreeRTOS_1_1MessageBufferBase.html#a06abfa89f97fac22e97be9f00ea7b553">More...</a><br /></td></tr>
<tr class="separator:a06abfa89f97fac22e97be9f00ea7b553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a033883bba3b46c4ffb892fd4656288ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#a033883bba3b46c4ffb892fd4656288ae">reset</a> () const</td></tr>
<tr class="memdesc:a033883bba3b46c4ffb892fd4656288ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xMessageBufferReset( MessageBufferHandle_t xMessageBuffer )</code>  <a href="classFreeRTOS_1_1MessageBufferBase.html#a033883bba3b46c4ffb892fd4656288ae">More...</a><br /></td></tr>
<tr class="separator:a033883bba3b46c4ffb892fd4656288ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a5f542f417f469b36e69c0901e6874"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#af8a5f542f417f469b36e69c0901e6874">isEmpty</a> () const</td></tr>
<tr class="memdesc:af8a5f542f417f469b36e69c0901e6874"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xMessageBufferIsEmpty( MessageBufferHandle_t xMessageBuffer )</code>  <a href="classFreeRTOS_1_1MessageBufferBase.html#af8a5f542f417f469b36e69c0901e6874">More...</a><br /></td></tr>
<tr class="separator:af8a5f542f417f469b36e69c0901e6874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a667729b1eca1d110f5b710cb683e5463"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#a667729b1eca1d110f5b710cb683e5463">isFull</a> () const</td></tr>
<tr class="memdesc:a667729b1eca1d110f5b710cb683e5463"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xMessageBufferIsFull( MessageBufferHandle_t xMessageBuffer )</code>  <a href="classFreeRTOS_1_1MessageBufferBase.html#a667729b1eca1d110f5b710cb683e5463">More...</a><br /></td></tr>
<tr class="separator:a667729b1eca1d110f5b710cb683e5463"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a39612500c7f3b26daffca878ead6629b"><td class="memItemLeft" align="right" valign="top"><a id="a39612500c7f3b26daffca878ead6629b"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t, void *ptr)</td></tr>
<tr class="separator:a39612500c7f3b26daffca878ead6629b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c3a21404fbf49931a8e8ebd460c9008"><td class="memItemLeft" align="right" valign="top"><a id="a9c3a21404fbf49931a8e8ebd460c9008"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t, void *ptr)</td></tr>
<tr class="separator:a9c3a21404fbf49931a8e8ebd460c9008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e71065a5f64421d7d1c57179655e5e5"><td class="memItemLeft" align="right" valign="top"><a id="a3e71065a5f64421d7d1c57179655e5e5"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t)=delete</td></tr>
<tr class="separator:a3e71065a5f64421d7d1c57179655e5e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab871cd535f0eb698d9d80a19ff367cfa"><td class="memItemLeft" align="right" valign="top"><a id="ab871cd535f0eb698d9d80a19ff367cfa"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t)=delete</td></tr>
<tr class="separator:ab871cd535f0eb698d9d80a19ff367cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:acb20badfea10e174795c9af58333093d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#acb20badfea10e174795c9af58333093d">~MessageBufferBase</a> ()</td></tr>
<tr class="memdesc:acb20badfea10e174795c9af58333093d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the <a class="el" href="classFreeRTOS_1_1MessageBufferBase.html" title="Base class that provides the standard message buffer interface to FreeRTOS::MessageBuffer and FreeRTO...">MessageBufferBase</a> object by calling <code>void vMessageBufferDelete( MessageBufferHandle_t xMessageBuffer )</code>  <a href="classFreeRTOS_1_1MessageBufferBase.html#acb20badfea10e174795c9af58333093d">More...</a><br /></td></tr>
<tr class="separator:acb20badfea10e174795c9af58333093d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06716433bd661e0908fc1257f7be8280"><td class="memItemLeft" align="right" valign="top"><a id="a06716433bd661e0908fc1257f7be8280"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MessageBufferBase</b> (<a class="el" href="classFreeRTOS_1_1MessageBufferBase.html">MessageBufferBase</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a06716433bd661e0908fc1257f7be8280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e963bd58e5758d04cea1287217d720e"><td class="memItemLeft" align="right" valign="top"><a id="a1e963bd58e5758d04cea1287217d720e"></a>
<a class="el" href="classFreeRTOS_1_1MessageBufferBase.html">MessageBufferBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classFreeRTOS_1_1MessageBufferBase.html">MessageBufferBase</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a1e963bd58e5758d04cea1287217d720e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a26323c17335d3651e4fcf8242c63f363"><td class="memItemLeft" align="right" valign="top"><a id="a26323c17335d3651e4fcf8242c63f363"></a>
MessageBufferHandle_t&#160;</td><td class="memItemRight" valign="bottom"><b>handle</b> = NULL</td></tr>
<tr class="separator:a26323c17335d3651e4fcf8242c63f363"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aefc103f33819ea2d455a576b71fcda0d"><td class="memItemLeft" align="right" valign="top"><a id="aefc103f33819ea2d455a576b71fcda0d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>MessageBuffer</b></td></tr>
<tr class="separator:aefc103f33819ea2d455a576b71fcda0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f80b66b8b99748b8a71a93edc55f8c"><td class="memTemplParams" colspan="2"><a id="ab7f80b66b8b99748b8a71a93edc55f8c"></a>
template&lt;size_t &gt; </td></tr>
<tr class="memitem:ab7f80b66b8b99748b8a71a93edc55f8c"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>StaticMessageBuffer</b></td></tr>
<tr class="separator:ab7f80b66b8b99748b8a71a93edc55f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class that provides the standard message buffer interface to <a class="el" href="classFreeRTOS_1_1MessageBuffer.html" title="Class that encapsulates the functionality of a FreeRTOS message buffer.">FreeRTOS::MessageBuffer</a> and <a class="el" href="classFreeRTOS_1_1StaticMessageBuffer.html" title="Class that encapsulates the functionality of a FreeRTOS message buffer.">FreeRTOS::StaticMessageBuffer</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This class is not intended to be instantiated by the user. Use <a class="el" href="classFreeRTOS_1_1MessageBuffer.html" title="Class that encapsulates the functionality of a FreeRTOS message buffer.">FreeRTOS::MessageBuffer</a> or <a class="el" href="classFreeRTOS_1_1StaticMessageBuffer.html" title="Class that encapsulates the functionality of a FreeRTOS message buffer.">FreeRTOS::StaticMessageBuffer</a>.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Uniquely among FreeRTOS objects, the stream buffer implementation (so also the message buffer implementation, as message buffers are built on top of stream buffers) assumes there is only one task or interrupt that will write to the buffer (the writer), and only one task or interrupt that will read from the buffer (the reader). It is safe for the writer and reader to be different tasks or interrupts, but, unlike other FreeRTOS objects, it is not safe to have multiple different writers or multiple different readers. If there are to be multiple different writers then the application writer must place each call to a writing API function (such as <a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#a14f4d52f5b4d90fd19524e6197f9547f" title="Function that calls size_t xMessageBufferSend( MessageBufferHandle_t xMessageBuffer,...">send()</a>) inside a critical section and set the send block time to 0. Likewise, if there are to be multiple different readers then the application writer must place each call to a reading API function (such as read()) inside a critical section and set the receive block time to 0. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acb20badfea10e174795c9af58333093d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb20badfea10e174795c9af58333093d">&#9670;&nbsp;</a></span>~MessageBufferBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">FreeRTOS::MessageBufferBase::~MessageBufferBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the <a class="el" href="classFreeRTOS_1_1MessageBufferBase.html" title="Base class that provides the standard message buffer interface to FreeRTOS::MessageBuffer and FreeRTO...">MessageBufferBase</a> object by calling <code>void vMessageBufferDelete( MessageBufferHandle_t xMessageBuffer )</code> </p>
<p><a class="el" href="MessageBuffer_8hpp_source.html">MessageBuffer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/vMessageBufferDelete.html">https://www.freertos.org/vMessageBufferDelete.html</a></dd></dl>
<p>Delete a queue - freeing all the memory allocated for storing of items placed on the queue. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af8a5f542f417f469b36e69c0901e6874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a5f542f417f469b36e69c0901e6874">&#9670;&nbsp;</a></span>isEmpty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::MessageBufferBase::isEmpty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xMessageBufferIsEmpty( MessageBufferHandle_t xMessageBuffer )</code> </p>
<p><a class="el" href="MessageBuffer_8hpp_source.html">MessageBuffer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xMessageBufferIsEmpty.html">https://www.freertos.org/xMessageBufferIsEmpty.html</a></dd></dl>
<p>Queries a message buffer to see if it is empty. A message buffer is empty if it does not contain any messages.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the message buffer is empty. </td></tr>
    <tr><td class="paramname">false</td><td>Otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a667729b1eca1d110f5b710cb683e5463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667729b1eca1d110f5b710cb683e5463">&#9670;&nbsp;</a></span>isFull()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::MessageBufferBase::isFull </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xMessageBufferIsFull( MessageBufferHandle_t xMessageBuffer )</code> </p>
<p><a class="el" href="MessageBuffer_8hpp_source.html">MessageBuffer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xMessageBufferIsFull.html">https://www.freertos.org/xMessageBufferIsFull.html</a></dd></dl>
<p>Queries a message buffer to see if it is full. A message buffer is full if it cannot accept any more messages, of any size, until space is made available by a message being removed from the message buffer.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the message buffer is full. </td></tr>
    <tr><td class="paramname">false</td><td>Otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95282112420e61271953947198f609e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95282112420e61271953947198f609e6">&#9670;&nbsp;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::MessageBufferBase::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that checks if the underlying message buffer handle is not NULL. This should be used to ensure a message buffer has been created correctly. </p>
<p><a class="el" href="MessageBuffer_8hpp_source.html">MessageBuffer.hpp</a></p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the handle is not NULL. </td></tr>
    <tr><td class="paramname">false</td><td>If the handle is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80533ab7f12e923b439539aa8f12e19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80533ab7f12e923b439539aa8f12e19d">&#9670;&nbsp;</a></span>receive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t FreeRTOS::MessageBufferBase::receive </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bufferLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TickType_t&#160;</td>
          <td class="paramname"><em>ticksToWait</em> = <code>portMAX_DELAY</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>size_t xMessageBufferReceive( MessageBufferHandle_t xMessageBuffer, void *pvRxData, size_t xBufferLengthBytes, TickType_t xTicksToWait )</code> </p>
<p><a class="el" href="MessageBuffer_8hpp_source.html">MessageBuffer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xMessageBufferReceive.html">https://www.freertos.org/xMessageBufferReceive.html</a></dd></dl>
<p>Use <a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#a80533ab7f12e923b439539aa8f12e19d" title="Function that calls size_t xMessageBufferReceive( MessageBufferHandle_t xMessageBuffer,...">receive()</a> to read from a message buffer from a task. UsereceiveFromISR() to read from a message buffer from an interrupt service routine (ISR).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer into which the received message is to be copied. </td></tr>
    <tr><td class="paramname">bufferLength</td><td>The length of the buffer pointed to by the buffer parameter. This sets the maximum length of the message that can be received. If bufferLength is too small to hold the next message then the message will be left in the message buffer and 0 will be returned. </td></tr>
    <tr><td class="paramname">ticksToWait</td><td>The maximum amount of time the task should remain in the Blocked state to wait for a message, should the message buffer be empty. <a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#a80533ab7f12e923b439539aa8f12e19d" title="Function that calls size_t xMessageBufferReceive( MessageBufferHandle_t xMessageBuffer,...">receive()</a> will return immediately if ticksToWait is zero and the message buffer is empty. The block time is specified in tick periods, so the absolute time it represents is dependent on the tick frequency. The macro pdMS_TO_TICKS() can be used to convert a time specified in milliseconds into a time specified in ticks. Setting ticksToWait to portMAX_DELAY will cause the task to wait indefinitely (without timing out), provided INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h. Tasks do not use any CPU time when they are in the Blocked state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The length, in bytes, of the message read from the message buffer, if any. If <a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#a80533ab7f12e923b439539aa8f12e19d" title="Function that calls size_t xMessageBufferReceive( MessageBufferHandle_t xMessageBuffer,...">receive()</a> times out before a message became available then zero is returned. If the length of the message is greater than bufferLength then the message will be left in the message buffer and zero is returned.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/MessageBuffer.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  MyTask() : messageBuffer(100) {}</div>
<div class="line">  <span class="keywordtype">void</span> taskFunction() final;</div>
<div class="line">  FreeRTOS::MessageBuffer messageBuffer;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTask::taskFunction() {</div>
<div class="line">  uint8_t ucRxData[20];</div>
<div class="line">  <span class="keywordtype">size_t</span> xReceivedBytes;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Receive the next message from the message buffer.  Wait in the Blocked</span></div>
<div class="line">  <span class="comment">// state (so not using any CPU processing time) for a maximum of 100ms for a</span></div>
<div class="line">  <span class="comment">// message to become available.</span></div>
<div class="line">  xReceivedBytes = messageBuffer.receive((<span class="keywordtype">void</span>*)ucRxData, <span class="keyword">sizeof</span>(ucRxData),</div>
<div class="line">                                         pdMS_TO_TICKS(20));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (xReceivedBytes &gt; 0) {</div>
<div class="line">    <span class="comment">// A ucRxData contains a message that is xReceivedBytes long.  Process the</span></div>
<div class="line">    <span class="comment">// message here...</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Rest of task code.</span></div>
<div class="line">}</div>
<div class="ttc" id="aclassFreeRTOS_1_1Task_html"><div class="ttname"><a href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a></div><div class="ttdoc">Class that encapsulates the functionality of a FreeRTOS task.</div><div class="ttdef"><b>Definition:</b> Task.hpp:1323</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac42521e68f9ac6ca8344a238f9043d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42521e68f9ac6ca8344a238f9043d9e">&#9670;&nbsp;</a></span>receiveFromISR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t FreeRTOS::MessageBufferBase::receiveFromISR </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>higherPriorityTaskWoken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bufferLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>size_t xMessageBufferReceiveFromISR( MessageBufferHandle_t xMessageBuffer, void *pvRxData, size_t xBufferLengthBytes, BaseType_t *pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="MessageBuffer_8hpp_source.html">MessageBuffer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xMessageBufferReceiveFromISR.html">https://www.freertos.org/xMessageBufferReceiveFromISR.html</a></dd></dl>
<p>Use <a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#a80533ab7f12e923b439539aa8f12e19d" title="Function that calls size_t xMessageBufferReceive( MessageBufferHandle_t xMessageBuffer,...">receive()</a> to read from a message buffer from a task. UsereceiveFromISR() to read from a message buffer from an interrupt service routine (ISR).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">higherPriorityTaskWoken</td><td>It is possible that a message buffer will have a task blocked on it waiting for space to become available. Calling <a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#ac42521e68f9ac6ca8344a238f9043d9e" title="Function that calls size_t xMessageBufferReceiveFromISR( MessageBufferHandle_t xMessageBuffer,...">receiveFromISR()</a> can make space available, and so cause a task that is waiting for space to leave the Blocked state. If calling <a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#ac42521e68f9ac6ca8344a238f9043d9e" title="Function that calls size_t xMessageBufferReceiveFromISR( MessageBufferHandle_t xMessageBuffer,...">receiveFromISR()</a> causes a task to leave the Blocked state, and the unblocked task has a priority higher than the currently executing task (the task that was interrupted), then, internally, <a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#ac42521e68f9ac6ca8344a238f9043d9e" title="Function that calls size_t xMessageBufferReceiveFromISR( MessageBufferHandle_t xMessageBuffer,...">receiveFromISR()</a> will set higherPriorityTaskWoken to true. If <a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#ac42521e68f9ac6ca8344a238f9043d9e" title="Function that calls size_t xMessageBufferReceiveFromISR( MessageBufferHandle_t xMessageBuffer,...">receiveFromISR()</a> sets this value to true, then normally a context switch should be performed before the interrupt is exited. That will ensure the interrupt returns directly to the highest priority Ready state task. higherPriorityTaskWoken should be set to false before it is passed into the function. See the code example below for an example. </td></tr>
    <tr><td class="paramname">buffer</td><td>A pointer to the buffer into which the received message is to be copied. </td></tr>
    <tr><td class="paramname">bufferLength</td><td>The length of the buffer pointed to by the buffer parameter. This sets the maximum length of the message that can be received. If bufferLength is too small to hold the next message then the message will be left in the message buffer and 0 will be returned. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The length, in bytes, of the message read from the message buffer, if any.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Kernel.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/MessageBuffer.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1StaticTask.html">FreeRTOS::StaticTask</a>&lt;configMINIMAL_STACK_SIZE&gt; {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  MyTask() : messageBuffer(100) {}</div>
<div class="line">  <span class="keywordtype">void</span> taskFunction() final;</div>
<div class="line">  FreeRTOS::MessageBuffer messageBuffer;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyTask task;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> anInterruptServiceRoutine() {</div>
<div class="line">  uint8_t ucRxData[20];</div>
<div class="line">  <span class="keywordtype">size_t</span> xReceivedBytes;</div>
<div class="line">  <span class="keywordtype">bool</span> higherPriorityTaskWoken = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Receive the next message from the message buffer.</span></div>
<div class="line">  xReceivedBytes = task.messageBuffer.receiveFromISR(</div>
<div class="line">      higherPriorityTaskWoken, (<span class="keywordtype">void</span>*)ucRxData, <span class="keyword">sizeof</span>(ucRxData));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (xReceivedBytes &gt; 0) {</div>
<div class="line">    <span class="comment">// ucRxData contains a message that is xReceivedBytes long.  Process the</span></div>
<div class="line">    <span class="comment">// message here...</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If higherPriorityTaskWoken was set to true inside receiveFromISR() then a</span></div>
<div class="line">  <span class="comment">// task that has a priority above the priority of the currently executing task</span></div>
<div class="line">  <span class="comment">// was unblocked and a context switch should be performed to ensure the ISR</span></div>
<div class="line">  <span class="comment">// returns to the unblocked task.  In most FreeRTOS ports this is done by</span></div>
<div class="line">  <span class="comment">// simply passing higherPriorityTaskWoken into FreeRTOS::yield(), which will</span></div>
<div class="line">  <span class="comment">// test the variables value, and perform the context switch if necessary.</span></div>
<div class="line">  <span class="comment">// Check the documentation for the port in use for port specific instructions.</span></div>
<div class="line">  <a class="code" href="namespaceFreeRTOS_1_1Kernel.html#aa22586993595ea064e411c0063096021">FreeRTOS::Kernel::yield</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclassFreeRTOS_1_1StaticTask_html"><div class="ttname"><a href="classFreeRTOS_1_1StaticTask.html">FreeRTOS::StaticTask</a></div><div class="ttdoc">Class that encapsulates the functionality of a FreeRTOS task.</div><div class="ttdef"><b>Definition:</b> Task.hpp:1423</div></div>
<div class="ttc" id="anamespaceFreeRTOS_1_1Kernel_html_aa22586993595ea064e411c0063096021"><div class="ttname"><a href="namespaceFreeRTOS_1_1Kernel.html#aa22586993595ea064e411c0063096021">FreeRTOS::Kernel::yield</a></div><div class="ttdeci">void yield()</div><div class="ttdoc">Function that calls taskYIELD()</div><div class="ttdef"><b>Definition:</b> Kernel.hpp:153</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a3858222ed39283a4179ed184c12ae949"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3858222ed39283a4179ed184c12ae949">&#9670;&nbsp;</a></span>receiveFromISR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t FreeRTOS::MessageBufferBase::receiveFromISR </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>bufferLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>size_t xMessageBufferReceiveFromISR( MessageBufferHandle_t xMessageBuffer, void *pvRxData, size_t xBufferLengthBytes, BaseType_t *pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="MessageBuffer_8hpp_source.html">MessageBuffer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xMessageBufferReceiveFromISR.html">https://www.freertos.org/xMessageBufferReceiveFromISR.html</a></dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a033883bba3b46c4ffb892fd4656288ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a033883bba3b46c4ffb892fd4656288ae">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool FreeRTOS::MessageBufferBase::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xMessageBufferReset( MessageBufferHandle_t xMessageBuffer )</code> </p>
<p><a class="el" href="MessageBuffer_8hpp_source.html">MessageBuffer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xMessageBufferReset.html">https://www.freertos.org/xMessageBufferReset.html</a></dd></dl>
<p>Resets a message buffer to its initial, empty, state. Any data that was in the message buffer is discarded. A message buffer can only be reset if there are no tasks blocked waiting to either send to or receive from the message buffer.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>If the message buffer is reset. </td></tr>
    <tr><td class="paramname">false</td><td>If there was a task blocked waiting to send to or read from the message buffer then the message buffer will not be reset. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14f4d52f5b4d90fd19524e6197f9547f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14f4d52f5b4d90fd19524e6197f9547f">&#9670;&nbsp;</a></span>send()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t FreeRTOS::MessageBufferBase::send </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TickType_t&#160;</td>
          <td class="paramname"><em>ticksToWait</em> = <code>portMAX_DELAY</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>size_t xMessageBufferSend( MessageBufferHandle_t xMessageBuffer, const void *pvTxData, size_t xDataLengthBytes, TickType_t xTicksToWait )</code> </p>
<p><a class="el" href="MessageBuffer_8hpp_source.html">MessageBuffer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xMessageBufferSend.html">https://www.freertos.org/xMessageBufferSend.html</a></dd></dl>
<p>Sends a discrete message to the message buffer. The message can be any length that fits within the buffer's free space, and is copied into the buffer.</p>
<p>Use <a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#a14f4d52f5b4d90fd19524e6197f9547f" title="Function that calls size_t xMessageBufferSend( MessageBufferHandle_t xMessageBuffer,...">send()</a> to write to a message buffer from a task. Use <a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#a37c01dca6f4fd0b969fb0596c53c8156" title="Function that calls size_t xMessageBufferSendFromISR( MessageBufferHandle_t xMessageBuffer,...">sendFromISR()</a> to write to a message buffer from an interrupt service routine (ISR).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>A pointer to the message that is to be copied into the message buffer. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the message. That is, the number of bytes to copy from data into the message buffer. When a message is written to the message buffer an additional sizeof( size_t ) bytes are also written to store the message's length. sizeof( size_t ) is typically 4 bytes on a 32-bit architecture, so on most 32-bit architecture setting length to 20 will reduce the free space in the message buffer by 24 bytes (20 bytes of message data and 4 bytes to hold the message length). </td></tr>
    <tr><td class="paramname">ticksToWait</td><td>The maximum amount of time the calling task should remain in the Blocked state to wait for enough space to become available in the message buffer, should the message buffer have insufficient space when <a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#a14f4d52f5b4d90fd19524e6197f9547f" title="Function that calls size_t xMessageBufferSend( MessageBufferHandle_t xMessageBuffer,...">send()</a> is called. The calling task will never block if ticksToWait is zero. The block time is specified in tick periods, so the absolute time it represents is dependent on the tick frequency. The macro pdMS_TO_TICKS() can be used to convert a time specified in milliseconds into a time specified in ticks. Setting ticksToWait to portMAX_DELAY will cause the task to wait indefinitely (without timing out), provided INCLUDE_vTaskSuspend is set to 1 in FreeRTOSConfig.h. Tasks do not use any CPU time when they are in the Blocked state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of bytes written to the message buffer. If the call to <a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#a14f4d52f5b4d90fd19524e6197f9547f" title="Function that calls size_t xMessageBufferSend( MessageBufferHandle_t xMessageBuffer,...">send()</a> times out before there was enough space to write the message into the message buffer then zero is returned. If the call did not time out then length is returned.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/MessageBuffer.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstring&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  MyTask() : messageBuffer(100) {}</div>
<div class="line">  <span class="keywordtype">void</span> taskFunction() final;</div>
<div class="line">  FreeRTOS::MessageBuffer messageBuffer;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTask::taskFunction() {</div>
<div class="line">  <span class="keywordtype">size_t</span> xBytesSent;</div>
<div class="line">  uint8_t ucArrayToSend[] = {0, 1, 2, 3};</div>
<div class="line">  <span class="keywordtype">char</span> <span class="keyword">const</span> *pcStringToSend = <span class="stringliteral">&quot;String to send&quot;</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Send an array to the message buffer, blocking for a maximum of 100ms to</span></div>
<div class="line">  <span class="comment">// wait for enough space to be available in the message buffer.</span></div>
<div class="line">  xBytesSent = messageBuffer.send(ucArrayToSend, <span class="keyword">sizeof</span>(ucArrayToSend),</div>
<div class="line">                                  pdMS_TO_TICKS(100));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (xBytesSent != <span class="keyword">sizeof</span>(ucArrayToSend)) {</div>
<div class="line">    <span class="comment">// The call to send() times out before there was enough space in the buffer</span></div>
<div class="line">    <span class="comment">// for the data to be written.</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Send the string to the message buffer.  Return immediately if there is not</span></div>
<div class="line">  <span class="comment">// enough space in the buffer.</span></div>
<div class="line">  xBytesSent = messageBuffer.send(pcStringToSend, strlen(pcStringToSend), 0);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (xBytesSent != strlen(pcStringToSend)) {</div>
<div class="line">    <span class="comment">// The string could not be added to the message buffer because there was not</span></div>
<div class="line">    <span class="comment">// enough free space in the buffer.</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Rest of task code.</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a37c01dca6f4fd0b969fb0596c53c8156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c01dca6f4fd0b969fb0596c53c8156">&#9670;&nbsp;</a></span>sendFromISR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t FreeRTOS::MessageBufferBase::sendFromISR </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>higherPriorityTaskWoken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>size_t xMessageBufferSendFromISR( MessageBufferHandle_t xMessageBuffer, const void *pvTxData, size_t xDataLengthBytes, BaseType_t *pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="MessageBuffer_8hpp_source.html">MessageBuffer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xMessageBufferSendFromISR.html">https://www.freertos.org/xMessageBufferSendFromISR.html</a></dd></dl>
<p>Interrupt safe version of the API function that sends a discrete message to the message buffer. The message can be any length that fits within the buffer's free space, and is copied into the buffer.</p>
<p>Use <a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#a14f4d52f5b4d90fd19524e6197f9547f" title="Function that calls size_t xMessageBufferSend( MessageBufferHandle_t xMessageBuffer,...">send()</a> to write to a message buffer from a task. Use <a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#a37c01dca6f4fd0b969fb0596c53c8156" title="Function that calls size_t xMessageBufferSendFromISR( MessageBufferHandle_t xMessageBuffer,...">sendFromISR()</a> to write to a message buffer from an interrupt service routine (ISR).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">higherPriorityTaskWoken</td><td>It is possible that a message buffer will have a task blocked on it waiting for data. Calling <a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#a37c01dca6f4fd0b969fb0596c53c8156" title="Function that calls size_t xMessageBufferSendFromISR( MessageBufferHandle_t xMessageBuffer,...">sendFromISR()</a> can make data available, and so cause a task that was waiting for data to leave the Blocked state. If calling <a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#a37c01dca6f4fd0b969fb0596c53c8156" title="Function that calls size_t xMessageBufferSendFromISR( MessageBufferHandle_t xMessageBuffer,...">sendFromISR()</a> causes a task to leave the Blocked state, and the unblocked task has a priority higher than the currently executing task (the task that was interrupted), then, internally, <a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#a37c01dca6f4fd0b969fb0596c53c8156" title="Function that calls size_t xMessageBufferSendFromISR( MessageBufferHandle_t xMessageBuffer,...">sendFromISR()</a> will set higherPriorityTaskWoken to true. If <a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#a37c01dca6f4fd0b969fb0596c53c8156" title="Function that calls size_t xMessageBufferSendFromISR( MessageBufferHandle_t xMessageBuffer,...">sendFromISR()</a> sets this value to true, then normally a context switch should be performed before the interrupt is exited. This will ensure that the interrupt returns directly to the highest priority Ready state task. higherPriorityTaskWoken should be set to false before it is passed into the function. See the code example below for an example. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to the message that is to be copied into the message buffer. </td></tr>
    <tr><td class="paramname">length</td><td>The length of the message. That is, the number of bytes to copy from data into the message buffer. When a message is written to the message buffer an additional sizeof( size_t ) bytes are also written to store the message's length. sizeof( size_t ) is typically 4 bytes on a 32-bit architecture, so on most 32-bit architecture setting length to 20 will reduce the free space in the message buffer by 24 bytes (20 bytes of message data and 4 bytes to hold the message length). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of bytes actually written to the message buffer. If the message buffer didn't have enough free space for the message to be stored then 0 is returned, otherwise length is returned.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Kernel.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/MessageBuffer.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstring&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1StaticTask.html">FreeRTOS::StaticTask</a>&lt;configMINIMAL_STACK_SIZE&gt; {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  MyTask() : messageBuffer(100) {}</div>
<div class="line">  <span class="keywordtype">void</span> taskFunction() final;</div>
<div class="line">  FreeRTOS::MessageBuffer messageBuffer;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">MyTask task;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> anInterruptServiceRoutine() {</div>
<div class="line">  <span class="keywordtype">char</span> <span class="keyword">const</span> *pcStringToSend = <span class="stringliteral">&quot;String to send&quot;</span>;</div>
<div class="line">  <span class="keywordtype">bool</span> higherPriorityTaskWoken = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Attempt to send the string to the message buffer.</span></div>
<div class="line">  <span class="keywordtype">size_t</span> xBytesSent = task.messageBuffer.sendFromISR(</div>
<div class="line">      higherPriorityTaskWoken, pcStringToSend, <span class="keyword">sizeof</span>(pcStringToSend));</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (xBytesSent != <span class="keyword">sizeof</span>(pcStringToSend)) {</div>
<div class="line">    <span class="comment">// The string could not be added to the message buffer because there was not</span></div>
<div class="line">    <span class="comment">// enough free space in the buffer.</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If higherPriorityTaskWoken was set to true inside sendFromISR() then a task</span></div>
<div class="line">  <span class="comment">// that has a priority above the priority of the currently executing task was</span></div>
<div class="line">  <span class="comment">// unblocked and a context switch should be performed to ensure the ISR</span></div>
<div class="line">  <span class="comment">// returns to the unblocked task.  In most FreeRTOS ports this is done by</span></div>
<div class="line">  <span class="comment">// simply passing higherPriorityTaskWoken into FreeRTOS::yield(), which will</span></div>
<div class="line">  <span class="comment">// test the variables value, and perform the context switch if necessary.</span></div>
<div class="line">  <span class="comment">// Check the documentation for the port in use for port specific instructions.</span></div>
<div class="line">  <a class="code" href="namespaceFreeRTOS_1_1Kernel.html#aa22586993595ea064e411c0063096021">FreeRTOS::Kernel::yield</a>();</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa4674426cb93c270ddb4f9c707e08dbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4674426cb93c270ddb4f9c707e08dbe">&#9670;&nbsp;</a></span>sendFromISR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t FreeRTOS::MessageBufferBase::sendFromISR </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>size_t xMessageBufferSendFromISR( MessageBufferHandle_t xMessageBuffer, const void *pvTxData, size_t xDataLengthBytes, BaseType_t *pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="MessageBuffer_8hpp_source.html">MessageBuffer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xMessageBufferSendFromISR.html">https://www.freertos.org/xMessageBufferSendFromISR.html</a></dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a06abfa89f97fac22e97be9f00ea7b553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06abfa89f97fac22e97be9f00ea7b553">&#9670;&nbsp;</a></span>spacesAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t FreeRTOS::MessageBufferBase::spacesAvailable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>size_t xMessageBufferSpacesAvailable( MessageBufferHandle_t xMessageBuffer )</code> </p>
<p><a class="el" href="MessageBuffer_8hpp_source.html">MessageBuffer.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xMessageBufferSpacesAvailable.html">https://www.freertos.org/xMessageBufferSpacesAvailable.html</a></dd></dl>
<p>Queries a message buffer to see how much free space it contains, which is equal to the amount of data that can be sent to the message buffer before it is full. The returned value is 4 bytes larger than the maximum message size that can be sent to the message buffer.</p>
<dl class="section return"><dt>Returns</dt><dd>size_t The number of bytes that can be written to the message buffer before the message buffer would be full. When a message is written to the message buffer an additional sizeof( size_t ) bytes are also written to store the message's length. sizeof( size_t ) is typically 4 bytes on a 32-bit architecture, so if <a class="el" href="classFreeRTOS_1_1MessageBufferBase.html#a06abfa89f97fac22e97be9f00ea7b553" title="Function that calls size_t xMessageBufferSpacesAvailable( MessageBufferHandle_t xMessageBuffer )">spacesAvailable()</a> returns 10, then the size of the largest message that can be written to the message buffer is 6 bytes. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/FreeRTOS-Cpp/FreeRTOS-Cpp/FreeRTOS-Cpp/include/FreeRTOS/<a class="el" href="MessageBuffer_8hpp_source.html">MessageBuffer.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
