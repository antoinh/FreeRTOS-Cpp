<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>FreeRTOS-Cpp: FreeRTOS::QueueBase&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">FreeRTOS-Cpp
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>FreeRTOS</b></li><li class="navelem"><a class="el" href="classFreeRTOS_1_1QueueBase.html">QueueBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classFreeRTOS_1_1QueueBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FreeRTOS::QueueBase&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Base class that provides the standard queue interface to <a class="el" href="classFreeRTOS_1_1Queue.html" title="Class that encapsulates the functionality of a FreeRTOS queue.">FreeRTOS::Queue</a> and <a class="el" href="classFreeRTOS_1_1StaticQueue.html" title="Class that encapsulates the functionality of a FreeRTOS queue.">FreeRTOS::StaticQueue</a>.  
 <a href="classFreeRTOS_1_1QueueBase.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Queue_8hpp_source.html">FreeRTOS/Queue.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FreeRTOS::QueueBase&lt; T &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classFreeRTOS_1_1QueueBase__inherit__graph.png" border="0" usemap="#FreeRTOS_1_1QueueBase_3_01T_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="FreeRTOS_1_1QueueBase_3_01T_01_4_inherit__map" id="FreeRTOS_1_1QueueBase_3_01T_01_4_inherit__map">
<area shape="rect" title="Base class that provides the standard queue interface to FreeRTOS::Queue and FreeRTOS::StaticQueue." alt="" coords="96,5,300,32"/>
<area shape="rect" href="classFreeRTOS_1_1Queue.html" title="Class that encapsulates the functionality of a FreeRTOS queue." alt="" coords="5,80,177,107"/>
<area shape="rect" href="classFreeRTOS_1_1StaticQueue.html" title="Class that encapsulates the functionality of a FreeRTOS queue." alt="" coords="201,80,411,107"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afc0f7853eefe1af74a4a698c39cb7fac"><td class="memItemLeft" align="right" valign="top"><a id="afc0f7853eefe1af74a4a698c39cb7fac"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QueueBase</b> (const <a class="el" href="classFreeRTOS_1_1QueueBase.html">QueueBase</a> &amp;)=delete</td></tr>
<tr class="separator:afc0f7853eefe1af74a4a698c39cb7fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe976277804116a81c6107b4810ae22f"><td class="memItemLeft" align="right" valign="top"><a id="abe976277804116a81c6107b4810ae22f"></a>
<a class="el" href="classFreeRTOS_1_1QueueBase.html">QueueBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classFreeRTOS_1_1QueueBase.html">QueueBase</a> &amp;)=delete</td></tr>
<tr class="separator:abe976277804116a81c6107b4810ae22f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af45bc5949e5c6eb5999b55dc2c82ddd6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#af45bc5949e5c6eb5999b55dc2c82ddd6">isValid</a> () const</td></tr>
<tr class="memdesc:af45bc5949e5c6eb5999b55dc2c82ddd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that checks if the underlying queue handle is not NULL. This should be used to ensure a queue has been created correctly.  <a href="classFreeRTOS_1_1QueueBase.html#af45bc5949e5c6eb5999b55dc2c82ddd6">More...</a><br /></td></tr>
<tr class="separator:af45bc5949e5c6eb5999b55dc2c82ddd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38ce516116ed1da212a1197a6bea0c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#ab38ce516116ed1da212a1197a6bea0c0">sendToBack</a> (const T &amp;item, const TickType_t ticksToWait=portMAX_DELAY) const</td></tr>
<tr class="memdesc:ab38ce516116ed1da212a1197a6bea0c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait )</code>  <a href="classFreeRTOS_1_1QueueBase.html#ab38ce516116ed1da212a1197a6bea0c0">More...</a><br /></td></tr>
<tr class="separator:ab38ce516116ed1da212a1197a6bea0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f7119c0502ca70b22d965fa123e4c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#a02f7119c0502ca70b22d965fa123e4c7">sendToBackFromISR</a> (bool &amp;higherPriorityTaskWoken, const T &amp;item) const</td></tr>
<tr class="memdesc:a02f7119c0502ca70b22d965fa123e4c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken )</code>  <a href="classFreeRTOS_1_1QueueBase.html#a02f7119c0502ca70b22d965fa123e4c7">More...</a><br /></td></tr>
<tr class="separator:a02f7119c0502ca70b22d965fa123e4c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e82628525bb1fc0737f4fa2af0373cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#a4e82628525bb1fc0737f4fa2af0373cf">sendToBackFromISR</a> (const T &amp;item) const</td></tr>
<tr class="memdesc:a4e82628525bb1fc0737f4fa2af0373cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken )</code>  <a href="classFreeRTOS_1_1QueueBase.html#a4e82628525bb1fc0737f4fa2af0373cf">More...</a><br /></td></tr>
<tr class="separator:a4e82628525bb1fc0737f4fa2af0373cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1bb5cf497c6e86a186a5e9cf6082c55"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#ae1bb5cf497c6e86a186a5e9cf6082c55">sendToFront</a> (const T &amp;item, const TickType_t ticksToWait=portMAX_DELAY) const</td></tr>
<tr class="memdesc:ae1bb5cf497c6e86a186a5e9cf6082c55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait )</code>  <a href="classFreeRTOS_1_1QueueBase.html#ae1bb5cf497c6e86a186a5e9cf6082c55">More...</a><br /></td></tr>
<tr class="separator:ae1bb5cf497c6e86a186a5e9cf6082c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ef1f391f1728466f678e4bf3882386"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#ad1ef1f391f1728466f678e4bf3882386">sendToFrontFromISR</a> (bool &amp;higherPriorityTaskWoken, const T &amp;item) const</td></tr>
<tr class="memdesc:ad1ef1f391f1728466f678e4bf3882386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>xQueueSendToFrontFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken )</code>  <a href="classFreeRTOS_1_1QueueBase.html#ad1ef1f391f1728466f678e4bf3882386">More...</a><br /></td></tr>
<tr class="separator:ad1ef1f391f1728466f678e4bf3882386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2781f1630fb21528e20b60b5ab052c1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#a2781f1630fb21528e20b60b5ab052c1e">sendToFrontFromISR</a> (const T &amp;item) const</td></tr>
<tr class="memdesc:a2781f1630fb21528e20b60b5ab052c1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>xQueueSendToFrontFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken )</code>  <a href="classFreeRTOS_1_1QueueBase.html#a2781f1630fb21528e20b60b5ab052c1e">More...</a><br /></td></tr>
<tr class="separator:a2781f1630fb21528e20b60b5ab052c1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14ed3a5ae6d648b680f85ec9140aed1"><td class="memItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#ae14ed3a5ae6d648b680f85ec9140aed1">receive</a> (const TickType_t ticksToWait=portMAX_DELAY) const</td></tr>
<tr class="memdesc:ae14ed3a5ae6d648b680f85ec9140aed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xQueueReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )</code>  <a href="classFreeRTOS_1_1QueueBase.html#ae14ed3a5ae6d648b680f85ec9140aed1">More...</a><br /></td></tr>
<tr class="separator:ae14ed3a5ae6d648b680f85ec9140aed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa4ecdebdc7342c205a426ff48b4aec"><td class="memItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#afaa4ecdebdc7342c205a426ff48b4aec">receiveFromISR</a> (bool &amp;higherPriorityTaskWoken) const</td></tr>
<tr class="memdesc:afaa4ecdebdc7342c205a426ff48b4aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxHigherPriorityTaskWoken )</code>  <a href="classFreeRTOS_1_1QueueBase.html#afaa4ecdebdc7342c205a426ff48b4aec">More...</a><br /></td></tr>
<tr class="separator:afaa4ecdebdc7342c205a426ff48b4aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75dd2a37bfc8488a0b49412f61774dd"><td class="memItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#ab75dd2a37bfc8488a0b49412f61774dd">receiveFromISR</a> () const</td></tr>
<tr class="memdesc:ab75dd2a37bfc8488a0b49412f61774dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxHigherPriorityTaskWoken )</code>  <a href="classFreeRTOS_1_1QueueBase.html#ab75dd2a37bfc8488a0b49412f61774dd">More...</a><br /></td></tr>
<tr class="separator:ab75dd2a37bfc8488a0b49412f61774dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a7b0773b1557fd81393ba94a7dac728"><td class="memItemLeft" align="right" valign="top">UBaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#a8a7b0773b1557fd81393ba94a7dac728">messagesWaiting</a> () const</td></tr>
<tr class="memdesc:a8a7b0773b1557fd81393ba94a7dac728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>UBaseType_t uxQueueMessagesWaiting( QueueHandle_t xQueue )</code>  <a href="classFreeRTOS_1_1QueueBase.html#a8a7b0773b1557fd81393ba94a7dac728">More...</a><br /></td></tr>
<tr class="separator:a8a7b0773b1557fd81393ba94a7dac728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ee16831d27efcce9ea4699fdf726afd"><td class="memItemLeft" align="right" valign="top">UBaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#a5ee16831d27efcce9ea4699fdf726afd">messagesWaitingFromISR</a> () const</td></tr>
<tr class="memdesc:a5ee16831d27efcce9ea4699fdf726afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>UBaseType_t uxQueueMessagesWaitingFromISR( QueueHandle_t xQueue )</code>  <a href="classFreeRTOS_1_1QueueBase.html#a5ee16831d27efcce9ea4699fdf726afd">More...</a><br /></td></tr>
<tr class="separator:a5ee16831d27efcce9ea4699fdf726afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d5f96189286ba25eb9d937f531632e5"><td class="memItemLeft" align="right" valign="top">UBaseType_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#a8d5f96189286ba25eb9d937f531632e5">spacesAvailable</a> () const</td></tr>
<tr class="memdesc:a8d5f96189286ba25eb9d937f531632e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>UBaseType_t uxQueueSpacesAvailable( QueueHandle_t xQueue )</code>  <a href="classFreeRTOS_1_1QueueBase.html#a8d5f96189286ba25eb9d937f531632e5">More...</a><br /></td></tr>
<tr class="separator:a8d5f96189286ba25eb9d937f531632e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ffb0db014492b760527ed4ba5b352bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#a4ffb0db014492b760527ed4ba5b352bf">reset</a> () const</td></tr>
<tr class="memdesc:a4ffb0db014492b760527ed4ba5b352bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xQueueReset( QueueHandle_t xQueue )</code>  <a href="classFreeRTOS_1_1QueueBase.html#a4ffb0db014492b760527ed4ba5b352bf">More...</a><br /></td></tr>
<tr class="separator:a4ffb0db014492b760527ed4ba5b352bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4974f07222576f4bbb0e4af9448ff9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#acf4974f07222576f4bbb0e4af9448ff9">overwrite</a> (const T &amp;item) const</td></tr>
<tr class="memdesc:acf4974f07222576f4bbb0e4af9448ff9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xQueueOverwrite( QueueHandle_t xQueue, const void * pvItemToQueue )</code>  <a href="classFreeRTOS_1_1QueueBase.html#acf4974f07222576f4bbb0e4af9448ff9">More...</a><br /></td></tr>
<tr class="separator:acf4974f07222576f4bbb0e4af9448ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39366d8cd04e9d8d08ec887564fecbbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#a39366d8cd04e9d8d08ec887564fecbbe">overwriteFromISR</a> (bool &amp;higherPriorityTaskWoken, const T &amp;item) const</td></tr>
<tr class="memdesc:a39366d8cd04e9d8d08ec887564fecbbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xQueueOverwriteFromISR( QueueHandle_t xQueue, const void * pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken )</code>  <a href="classFreeRTOS_1_1QueueBase.html#a39366d8cd04e9d8d08ec887564fecbbe">More...</a><br /></td></tr>
<tr class="separator:a39366d8cd04e9d8d08ec887564fecbbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a9fba26bf6b5d4521fb5601111ccce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#aa7a9fba26bf6b5d4521fb5601111ccce">overwriteFromISR</a> (const T &amp;item) const</td></tr>
<tr class="memdesc:aa7a9fba26bf6b5d4521fb5601111ccce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xQueueOverwriteFromISR( QueueHandle_t xQueue, const void * pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken )</code>  <a href="classFreeRTOS_1_1QueueBase.html#aa7a9fba26bf6b5d4521fb5601111ccce">More...</a><br /></td></tr>
<tr class="separator:aa7a9fba26bf6b5d4521fb5601111ccce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9871e7011ac00cf50e12cbf4a41d2201"><td class="memItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#a9871e7011ac00cf50e12cbf4a41d2201">peek</a> (const TickType_t ticksToWait=portMAX_DELAY) const</td></tr>
<tr class="memdesc:a9871e7011ac00cf50e12cbf4a41d2201"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )</code>  <a href="classFreeRTOS_1_1QueueBase.html#a9871e7011ac00cf50e12cbf4a41d2201">More...</a><br /></td></tr>
<tr class="separator:a9871e7011ac00cf50e12cbf4a41d2201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33589c7311a79aa47488ab8eabe18782"><td class="memItemLeft" align="right" valign="top">std::optional&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#a33589c7311a79aa47488ab8eabe18782">peekFromISR</a> () const</td></tr>
<tr class="memdesc:a33589c7311a79aa47488ab8eabe18782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void *pvBuffer )</code>  <a href="classFreeRTOS_1_1QueueBase.html#a33589c7311a79aa47488ab8eabe18782">More...</a><br /></td></tr>
<tr class="separator:a33589c7311a79aa47488ab8eabe18782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ce0f34fcc0ccc84c3898dd6f28fd02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#aa2ce0f34fcc0ccc84c3898dd6f28fd02">addToRegistry</a> (const char *name) const</td></tr>
<tr class="memdesc:aa2ce0f34fcc0ccc84c3898dd6f28fd02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>void vQueueAddToRegistry( QueueHandle_t xQueue, char *pcQueueName )</code>  <a href="classFreeRTOS_1_1QueueBase.html#aa2ce0f34fcc0ccc84c3898dd6f28fd02">More...</a><br /></td></tr>
<tr class="separator:aa2ce0f34fcc0ccc84c3898dd6f28fd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51ec0de8264da31fdaa6b348694024e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#aa51ec0de8264da31fdaa6b348694024e">unregister</a> () const</td></tr>
<tr class="memdesc:aa51ec0de8264da31fdaa6b348694024e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>void vQueueUnregisterQueue( QueueHandle_t xQueue )</code>  <a href="classFreeRTOS_1_1QueueBase.html#aa51ec0de8264da31fdaa6b348694024e">More...</a><br /></td></tr>
<tr class="separator:aa51ec0de8264da31fdaa6b348694024e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c706f3273415faaccc44eefb3230b1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#a14c706f3273415faaccc44eefb3230b1">getName</a> () const</td></tr>
<tr class="memdesc:a14c706f3273415faaccc44eefb3230b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>const char *pcQueueGetName( QueueHandle_t xQueue )</code>  <a href="classFreeRTOS_1_1QueueBase.html#a14c706f3273415faaccc44eefb3230b1">More...</a><br /></td></tr>
<tr class="separator:a14c706f3273415faaccc44eefb3230b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a235fcf4da3ebc5b597af8d253ce2031f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#a235fcf4da3ebc5b597af8d253ce2031f">isFullFromISR</a> () const</td></tr>
<tr class="memdesc:a235fcf4da3ebc5b597af8d253ce2031f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )</code>  <a href="classFreeRTOS_1_1QueueBase.html#a235fcf4da3ebc5b597af8d253ce2031f">More...</a><br /></td></tr>
<tr class="separator:a235fcf4da3ebc5b597af8d253ce2031f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e9c1c32a1ac1fed1fc7fdf00b6ecf3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#ad6e9c1c32a1ac1fed1fc7fdf00b6ecf3">isEmptyFromISR</a> () const</td></tr>
<tr class="memdesc:ad6e9c1c32a1ac1fed1fc7fdf00b6ecf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function that calls <code>BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )</code>  <a href="classFreeRTOS_1_1QueueBase.html#ad6e9c1c32a1ac1fed1fc7fdf00b6ecf3">More...</a><br /></td></tr>
<tr class="separator:ad6e9c1c32a1ac1fed1fc7fdf00b6ecf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:af7d562065e990701a2c230f942b4c7b3"><td class="memItemLeft" align="right" valign="top"><a id="af7d562065e990701a2c230f942b4c7b3"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t, void *)</td></tr>
<tr class="separator:af7d562065e990701a2c230f942b4c7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac794a60178b77c65a17d2035b71ec0e2"><td class="memItemLeft" align="right" valign="top"><a id="ac794a60178b77c65a17d2035b71ec0e2"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t, void *)</td></tr>
<tr class="separator:ac794a60178b77c65a17d2035b71ec0e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c73d75677643ae87efbb075d8c0462f"><td class="memItemLeft" align="right" valign="top"><a id="a6c73d75677643ae87efbb075d8c0462f"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new</b> (size_t)=delete</td></tr>
<tr class="separator:a6c73d75677643ae87efbb075d8c0462f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accb1288ab062c114fbfa824fedc22795"><td class="memItemLeft" align="right" valign="top"><a id="accb1288ab062c114fbfa824fedc22795"></a>
static void *&#160;</td><td class="memItemRight" valign="bottom"><b>operator new[]</b> (size_t)=delete</td></tr>
<tr class="separator:accb1288ab062c114fbfa824fedc22795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab113aecb8692dc8c4c936245e1f2cc85"><td class="memItemLeft" align="right" valign="top"><a id="ab113aecb8692dc8c4c936245e1f2cc85"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete</b> (void *)=delete</td></tr>
<tr class="separator:ab113aecb8692dc8c4c936245e1f2cc85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6fa790107c700bec5dec002951affc"><td class="memItemLeft" align="right" valign="top"><a id="aea6fa790107c700bec5dec002951affc"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>operator delete[]</b> (void *)=delete</td></tr>
<tr class="separator:aea6fa790107c700bec5dec002951affc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a9f4d54a95c2bef76677d272d6dee5243"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#a9f4d54a95c2bef76677d272d6dee5243">QueueBase</a> ()=default</td></tr>
<tr class="memdesc:a9f4d54a95c2bef76677d272d6dee5243"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classFreeRTOS_1_1QueueBase.html" title="Base class that provides the standard queue interface to FreeRTOS::Queue and FreeRTOS::StaticQueue.">QueueBase</a> object.  <a href="classFreeRTOS_1_1QueueBase.html#a9f4d54a95c2bef76677d272d6dee5243">More...</a><br /></td></tr>
<tr class="separator:a9f4d54a95c2bef76677d272d6dee5243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf5b691c9bcfb8dedb863f142a8fd5e3"><td class="memItemLeft" align="right" valign="top"><a id="acf5b691c9bcfb8dedb863f142a8fd5e3"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>QueueBase</b> (<a class="el" href="classFreeRTOS_1_1QueueBase.html">QueueBase</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:acf5b691c9bcfb8dedb863f142a8fd5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b3c1376f85332e38e579bb4dbc23c7"><td class="memItemLeft" align="right" valign="top"><a id="a64b3c1376f85332e38e579bb4dbc23c7"></a>
<a class="el" href="classFreeRTOS_1_1QueueBase.html">QueueBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (<a class="el" href="classFreeRTOS_1_1QueueBase.html">QueueBase</a> &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a64b3c1376f85332e38e579bb4dbc23c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a415a7f65d8de9886fdeb470230b576a0"><td class="memItemLeft" align="right" valign="top"><a id="a415a7f65d8de9886fdeb470230b576a0"></a>
QueueHandle_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFreeRTOS_1_1QueueBase.html#a415a7f65d8de9886fdeb470230b576a0">handle</a> = NULL</td></tr>
<tr class="memdesc:a415a7f65d8de9886fdeb470230b576a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle used to refer to the queue when using the FreeRTOS interface. <br /></td></tr>
<tr class="separator:a415a7f65d8de9886fdeb470230b576a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a76db68f71f6e65aa4083615ee111ab59"><td class="memTemplParams" colspan="2"><a id="a76db68f71f6e65aa4083615ee111ab59"></a>
template&lt;class &gt; </td></tr>
<tr class="memitem:a76db68f71f6e65aa4083615ee111ab59"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Queue</b></td></tr>
<tr class="separator:a76db68f71f6e65aa4083615ee111ab59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a021c2a6f7f8aefec06b53469bd2ad155"><td class="memTemplParams" colspan="2"><a id="a021c2a6f7f8aefec06b53469bd2ad155"></a>
template&lt;class , UBaseType_t &gt; </td></tr>
<tr class="memitem:a021c2a6f7f8aefec06b53469bd2ad155"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>StaticQueue</b></td></tr>
<tr class="separator:a021c2a6f7f8aefec06b53469bd2ad155"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class T&gt;<br />
class FreeRTOS::QueueBase&lt; T &gt;</h3>

<p>Base class that provides the standard queue interface to <a class="el" href="classFreeRTOS_1_1Queue.html" title="Class that encapsulates the functionality of a FreeRTOS queue.">FreeRTOS::Queue</a> and <a class="el" href="classFreeRTOS_1_1StaticQueue.html" title="Class that encapsulates the functionality of a FreeRTOS queue.">FreeRTOS::StaticQueue</a>. </p>
<dl class="section note"><dt>Note</dt><dd>This class is not intended to be instantiated by the user. Use <a class="el" href="classFreeRTOS_1_1Queue.html" title="Class that encapsulates the functionality of a FreeRTOS queue.">FreeRTOS::Queue</a> or <a class="el" href="classFreeRTOS_1_1StaticQueue.html" title="Class that encapsulates the functionality of a FreeRTOS queue.">FreeRTOS::StaticQueue</a>.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type to be stored in the queue. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9f4d54a95c2bef76677d272d6dee5243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4d54a95c2bef76677d272d6dee5243">&#9670;&nbsp;</a></span>QueueBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::<a class="el" href="classFreeRTOS_1_1QueueBase.html">QueueBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classFreeRTOS_1_1QueueBase.html" title="Base class that provides the standard queue interface to FreeRTOS::Queue and FreeRTOS::StaticQueue.">QueueBase</a> object. </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="section note"><dt>Note</dt><dd>Default constructor is deliberately private as this class is not intended to be instantiated or derived from by the user. Use <a class="el" href="classFreeRTOS_1_1Queue.html" title="Class that encapsulates the functionality of a FreeRTOS queue.">FreeRTOS::Queue</a> or <a class="el" href="classFreeRTOS_1_1StaticQueue.html" title="Class that encapsulates the functionality of a FreeRTOS queue.">FreeRTOS::StaticQueue</a>. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa2ce0f34fcc0ccc84c3898dd6f28fd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ce0f34fcc0ccc84c3898dd6f28fd02">&#9670;&nbsp;</a></span>addToRegistry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::addToRegistry </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>void vQueueAddToRegistry( QueueHandle_t xQueue, char *pcQueueName )</code> </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/vQueueAddToRegistry.html">https://www.freertos.org/vQueueAddToRegistry.html</a></dd></dl>
<p>The registry is provided as a means for kernel aware debuggers to locate queues, semaphores and mutexes. Call <a class="el" href="classFreeRTOS_1_1QueueBase.html#aa2ce0f34fcc0ccc84c3898dd6f28fd02" title="Function that calls void vQueueAddToRegistry( QueueHandle_t xQueue, char *pcQueueName )">addToRegistry()</a> add a queue, semaphore or mutex handle to the registry if you want the handle to be available to a kernel aware debugger. If you are not using a kernel aware debugger then this function can be ignored.</p>
<p>configQUEUE_REGISTRY_SIZE defines the maximum number of handles the registry can hold. configQUEUE_REGISTRY_SIZE must be greater than 0 within FreeRTOSConfig.h for the registry to be available. Its value does not effect the number of queues, semaphores and mutexes that can be created - just the number that the registry can hold.</p>
<p>If <a class="el" href="classFreeRTOS_1_1QueueBase.html#aa2ce0f34fcc0ccc84c3898dd6f28fd02" title="Function that calls void vQueueAddToRegistry( QueueHandle_t xQueue, char *pcQueueName )">addToRegistry()</a> is called more than once for the same queue, the registry will store the name parameter from the most recent call to <a class="el" href="classFreeRTOS_1_1QueueBase.html#aa2ce0f34fcc0ccc84c3898dd6f28fd02" title="Function that calls void vQueueAddToRegistry( QueueHandle_t xQueue, char *pcQueueName )">addToRegistry()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>The name to be associated with the handle. This is the name that the kernel aware debugger will display. The queue registry only stores a pointer to the string - so the string must be persistent (global or preferably in ROM/Flash), not on the stack. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14c706f3273415faaccc44eefb3230b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c706f3273415faaccc44eefb3230b1">&#9670;&nbsp;</a></span>getName()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* <a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::getName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>const char *pcQueueGetName( QueueHandle_t xQueue )</code> </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/pcQueueGetName.html">https://www.freertos.org/pcQueueGetName.html</a></dd></dl>
<p>The queue registry is provided as a means for kernel aware debuggers to locate queues, semaphores and mutexes. Call <a class="el" href="classFreeRTOS_1_1QueueBase.html#a14c706f3273415faaccc44eefb3230b1" title="Function that calls const char *pcQueueGetName( QueueHandle_t xQueue )">getName()</a> to look up and return the name of a queue in the queue registry from the queue's handle.</p>
<dl class="section return"><dt>Returns</dt><dd>If the queue referenced by the queue is in the queue registry, then the text name of the queue is returned, otherwise NULL is returned. </dd></dl>

</div>
</div>
<a id="ad6e9c1c32a1ac1fed1fc7fdf00b6ecf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6e9c1c32a1ac1fed1fc7fdf00b6ecf3">&#9670;&nbsp;</a></span>isEmptyFromISR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::isEmptyFromISR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )</code> </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/a00018.html#xQueueIsQueueEmptyFromISR">https://www.freertos.org/a00018.html#xQueueIsQueueEmptyFromISR</a></dd></dl>
<p>Queries a queue to determine if the queue is empty. This function should only be used in an ISR.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the queue is empty. </td></tr>
    <tr><td class="paramname">false</td><td>if the queue is not empty. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a235fcf4da3ebc5b597af8d253ce2031f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a235fcf4da3ebc5b597af8d253ce2031f">&#9670;&nbsp;</a></span>isFullFromISR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::isFullFromISR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )</code> </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/a00018.html#xQueueIsQueueFullFromISR">https://www.freertos.org/a00018.html#xQueueIsQueueFullFromISR</a></dd></dl>
<p>Queries a queue to determine if the queue is empty. This function should only be used in an ISR.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the queue is full. </dd>
<dd>
false if the queue is not full. </dd></dl>

</div>
</div>
<a id="af45bc5949e5c6eb5999b55dc2c82ddd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af45bc5949e5c6eb5999b55dc2c82ddd6">&#9670;&nbsp;</a></span>isValid()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::isValid </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that checks if the underlying queue handle is not NULL. This should be used to ensure a queue has been created correctly. </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>the handle is not NULL. </td></tr>
    <tr><td class="paramname">false</td><td>the handle is NULL. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a7b0773b1557fd81393ba94a7dac728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a7b0773b1557fd81393ba94a7dac728">&#9670;&nbsp;</a></span>messagesWaiting()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UBaseType_t <a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::messagesWaiting </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>UBaseType_t uxQueueMessagesWaiting( QueueHandle_t xQueue )</code> </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/a00018.html#ucQueueMessagesWaiting">https://www.freertos.org/a00018.html#ucQueueMessagesWaiting</a></dd></dl>
<p>Return the number of messages stored in a queue.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">UBaseType_t</td><td>The number of messages available in the queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ee16831d27efcce9ea4699fdf726afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ee16831d27efcce9ea4699fdf726afd">&#9670;&nbsp;</a></span>messagesWaitingFromISR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UBaseType_t <a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::messagesWaitingFromISR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>UBaseType_t uxQueueMessagesWaitingFromISR( QueueHandle_t xQueue )</code> </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/a00018.html#ucQueueMessagesWaitingFromISR">https://www.freertos.org/a00018.html#ucQueueMessagesWaitingFromISR</a></dd></dl>
<p>A version of <a class="el" href="classFreeRTOS_1_1QueueBase.html#a8a7b0773b1557fd81393ba94a7dac728" title="Function that calls UBaseType_t uxQueueMessagesWaiting( QueueHandle_t xQueue )">messagesWaiting()</a> that can be called from an ISR. Return the number of messages stored in a queue.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">UBaseType_t</td><td>The number of messages available in the queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf4974f07222576f4bbb0e4af9448ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4974f07222576f4bbb0e4af9448ff9">&#9670;&nbsp;</a></span>overwrite()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::overwrite </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xQueueOverwrite( QueueHandle_t xQueue, const void * pvItemToQueue )</code> </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xQueueOverwrite.html">https://www.freertos.org/xQueueOverwrite.html</a></dd></dl>
<p>Only for use with queues that have a length of one - so the queue is either empty or full.</p>
<p>Post an item on a queue. If the queue is already full then overwrite the value held in the queue. The item is queued by copy, not by reference.</p>
<p>This function must not be called from an interrupt service routine. See <a class="el" href="classFreeRTOS_1_1QueueBase.html#a39366d8cd04e9d8d08ec887564fecbbe" title="Function that calls BaseType_t xQueueOverwriteFromISR( QueueHandle_t xQueue, const void * pvItemToQue...">overwriteFromISR()</a> for an alternative which may be used in an ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>A reference to the item that is to be placed on the queue.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Queue.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> taskFunction() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTask::taskFunction() {</div>
<div class="line">  <span class="comment">// Create a queue to hold one unsigned long value.  It is strongly recommended</span></div>
<div class="line">  <span class="comment">// *not* to use overwrite() on queues that can contain more than one value,</span></div>
<div class="line">  <span class="comment">// and doing so will trigger an assertion if configASSERT() is defined.</span></div>
<div class="line">  <a class="code" href="classFreeRTOS_1_1Queue.html">FreeRTOS::Queue&lt;uint64_t&gt;</a> queue(1);</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (!queue.isValid()) {</div>
<div class="line">    <span class="comment">// Queue was not created and must not be used.</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Write the value 10 to the queue using overwrite().</span></div>
<div class="line">  queue.overwrite(10);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Peeking the queue should now return 10, but leave the value 10 in the</span></div>
<div class="line">  <span class="comment">// queue.  A block time of zero is used as it is known that the queue holds a</span></div>
<div class="line">  <span class="comment">// value.</span></div>
<div class="line">  <span class="keywordflow">if</span> (queue.peek().value() != 10) {</div>
<div class="line">    <span class="comment">// Error, unless another task removed the value.</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The queue is still full.  Use overwrite() to overwrite the value held in</span></div>
<div class="line">  <span class="comment">// the queue with 100.</span></div>
<div class="line">  queue.overwrite(100);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// This time read from the queue, leaving the queue empty once more.  A block</span></div>
<div class="line">  <span class="comment">// time of 0 is used again. The value read should be the last value written,</span></div>
<div class="line">  <span class="comment">// even though the queue was already full when the value was written.</span></div>
<div class="line">  <span class="keywordflow">if</span> (queue.receive().value() != 100) {</div>
<div class="line">    <span class="comment">// Error unless another task is using the same queue.</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a39366d8cd04e9d8d08ec887564fecbbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39366d8cd04e9d8d08ec887564fecbbe">&#9670;&nbsp;</a></span>overwriteFromISR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::overwriteFromISR </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>higherPriorityTaskWoken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xQueueOverwriteFromISR( QueueHandle_t xQueue, const void * pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xQueueOverwriteFromISR.html">https://www.freertos.org/xQueueOverwriteFromISR.html</a></dd></dl>
<p>A version of <a class="el" href="classFreeRTOS_1_1QueueBase.html#acf4974f07222576f4bbb0e4af9448ff9" title="Function that calls BaseType_t xQueueOverwrite( QueueHandle_t xQueue, const void * pvItemToQueue )">overwrite()</a> that can be used in an interrupt service routine (ISR).</p>
<p>Only for use with queues that can hold a single item - so the queue is either empty or full.</p>
<p>Post an item on a queue. If the queue is already full then overwrite the value held in the queue. The item is queued by copy, not by reference.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">higherPriorityTaskWoken</td><td>A reference that will be set to true if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. </td></tr>
    <tr><td class="paramname">item</td><td>A reference to the item that is to be placed on the queue.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Kernel.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Queue.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Create a queue to hold one unsigned long value.  It is strongly recommended</span></div>
<div class="line"><span class="comment">// not to use overwriteFromISR() on queues that can contain more than one value,</span></div>
<div class="line"><span class="comment">// and doing so will trigger an assertion if configASSERT() is defined.</span></div>
<div class="line"><a class="code" href="classFreeRTOS_1_1StaticQueue.html">FreeRTOS::StaticQueue&lt;uint64_t, 1&gt;</a> queue;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> anInterruptHandler() {</div>
<div class="line">  <span class="keywordtype">bool</span> higherPriorityTaskWoken = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Write the value 10 to the queue using overwriteFromISR().</span></div>
<div class="line">  queue.<a class="code" href="classFreeRTOS_1_1QueueBase.html#a39366d8cd04e9d8d08ec887564fecbbe">overwriteFromISR</a>(higherPriorityTaskWoken, 10);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// The queue is full, but calling overwriteFromISR() again will still pass</span></div>
<div class="line">  <span class="comment">// because the value held in the queue will be overwritten with the new value.</span></div>
<div class="line">  queue.<a class="code" href="classFreeRTOS_1_1QueueBase.html#a39366d8cd04e9d8d08ec887564fecbbe">overwriteFromISR</a>(higherPriorityTaskWoken, 100);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Reading from the queue will now return 100.</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (higherPriorityTaskWoken) {</div>
<div class="line">    <span class="comment">// Writing to the queue caused a task to unblock and the unblocked task has</span></div>
<div class="line">    <span class="comment">// a priority higher than or equal to the priority of the currently</span></div>
<div class="line">    <span class="comment">// executing task (the task this interrupt interrupted).  Perform a context</span></div>
<div class="line">    <span class="comment">// switch so this interrupt returns directly to the unblocked task.</span></div>
<div class="line">    <a class="code" href="namespaceFreeRTOS_1_1Kernel.html#aa22586993595ea064e411c0063096021">FreeRTOS::Kernel::yield</a>();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="aa7a9fba26bf6b5d4521fb5601111ccce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7a9fba26bf6b5d4521fb5601111ccce">&#9670;&nbsp;</a></span>overwriteFromISR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::overwriteFromISR </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xQueueOverwriteFromISR( QueueHandle_t xQueue, const void * pvItemToQueue, BaseType_t *pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xQueueOverwriteFromISR.html">https://www.freertos.org/xQueueOverwriteFromISR.html</a></dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a9871e7011ac00cf50e12cbf4a41d2201"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9871e7011ac00cf50e12cbf4a41d2201">&#9670;&nbsp;</a></span>peek()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;T&gt; <a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::peek </td>
          <td>(</td>
          <td class="paramtype">const TickType_t&#160;</td>
          <td class="paramname"><em>ticksToWait</em> = <code>portMAX_DELAY</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )</code> </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xQueuePeek.html">https://www.freertos.org/xQueuePeek.html</a></dd></dl>
<p>Receive an item from a queue without removing the item from the queue.</p>
<p>Successfully received items remain on the queue so will be returned again by the next call, or a call to <a class="el" href="classFreeRTOS_1_1QueueBase.html#ae14ed3a5ae6d648b680f85ec9140aed1" title="Function that calls BaseType_t xQueueReceive( QueueHandle_t xQueue, void *pvBuffer,...">receive()</a>.</p>
<p>This function must not be used in an interrupt service routine. See <a class="el" href="classFreeRTOS_1_1QueueBase.html#a33589c7311a79aa47488ab8eabe18782" title="Function that calls BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void *pvBuffer )">peekFromISR()</a> for an alternative that can be called from an interrupt service routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ticksToWait</td><td>The maximum amount of time the task should block waiting for an item to receive should the queue be empty at the time of the call. Setting ticksToWait to 0 will cause the function to return immediately if the queue is empty. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::optional&lt;T&gt; Object from the queue. User should check that the value is present.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Queue.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> taskFunction() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">class MyDifferentTask : public FreeRTOS::Task {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> taskFunction() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">class Message {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">char</span> ucMessageID;</div>
<div class="line">  <span class="keywordtype">char</span> ucData[20];</div>
<div class="line">} xMessage;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Queue used to send and receive pointers to Message objects.</span></div>
<div class="line"><a class="code" href="classFreeRTOS_1_1StaticQueue.html">FreeRTOS::StaticQueue&lt;Message*, 10&gt;</a> pointerQueue;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTask::taskFunction() {</div>
<div class="line">  <span class="comment">// Send a pointer to a Message object.  Don&#39;t block if the queue is already</span></div>
<div class="line">  <span class="comment">// full.</span></div>
<div class="line">  pointerQueue.<a class="code" href="classFreeRTOS_1_1QueueBase.html#ab38ce516116ed1da212a1197a6bea0c0">sendToBack</a>(&amp;xMessage);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ... Rest of task code goes here.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyDifferentTask::taskFunction() {</div>
<div class="line">  <span class="comment">// Peek a message on the created queue.  Block for 10 ticks if a message is</span></div>
<div class="line">  <span class="comment">// not immediately available.</span></div>
<div class="line">  <span class="keywordflow">if</span> (<span class="keyword">auto</span> messagePointer = pointerQueue.<a class="code" href="classFreeRTOS_1_1QueueBase.html#a9871e7011ac00cf50e12cbf4a41d2201">peek</a>(10)) {</div>
<div class="line">    <span class="comment">// messagePointer now points to the xMessage variable posted by MyTask, but</span></div>
<div class="line">    <span class="comment">// the item still remains on the queue.</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ... Rest of task code goes here.</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a33589c7311a79aa47488ab8eabe18782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33589c7311a79aa47488ab8eabe18782">&#9670;&nbsp;</a></span>peekFromISR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;T&gt; <a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::peekFromISR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void *pvBuffer )</code> </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xQueuePeekFromISR.html">https://www.freertos.org/xQueuePeekFromISR.html</a></dd></dl>
<p>A version of <a class="el" href="classFreeRTOS_1_1QueueBase.html#a9871e7011ac00cf50e12cbf4a41d2201" title="Function that calls BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer,...">peek()</a> that can be called from an interrupt service routine (ISR).</p>
<p>Receive an item from a queue without removing the item from the queue.</p>
<p>Successfully received items remain on the queue so will be returned again by the next call, or a call to <a class="el" href="classFreeRTOS_1_1QueueBase.html#ae14ed3a5ae6d648b680f85ec9140aed1" title="Function that calls BaseType_t xQueueReceive( QueueHandle_t xQueue, void *pvBuffer,...">receive()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>std::optional&lt;T&gt; Object from the queue. User should check that the value is present. </dd></dl>

</div>
</div>
<a id="ae14ed3a5ae6d648b680f85ec9140aed1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14ed3a5ae6d648b680f85ec9140aed1">&#9670;&nbsp;</a></span>receive()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;T&gt; <a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::receive </td>
          <td>(</td>
          <td class="paramtype">const TickType_t&#160;</td>
          <td class="paramname"><em>ticksToWait</em> = <code>portMAX_DELAY</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xQueueReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )</code> </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/a00118.html">https://www.freertos.org/a00118.html</a></dd></dl>
<p>Receive an item from a queue. This function must not be used in an interrupt service routine. See <a class="el" href="classFreeRTOS_1_1QueueBase.html#afaa4ecdebdc7342c205a426ff48b4aec" title="Function that calls BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer,...">receiveFromISR()</a> for an alternative that can.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ticksToWait</td><td>The maximum amount of time the task should block waiting for an item to receive should the queue be empty at the time of the call. Setting ticksToWait to 0 will cause the function to return immediately if the queue is empty. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::optional&lt;T&gt; Object from the queue. User should check that the value is present.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Queue.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> taskFunction() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">class MyDifferentTask : public FreeRTOS::Task {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> taskFunction() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Define a variable of type Message.  The examples below demonstrate how to</span></div>
<div class="line"><span class="comment">// pass the whole variable through the queue, and as the structure is moderately</span></div>
<div class="line"><span class="comment">// large, also how to pass a reference to the variable through a queue.</span></div>
<div class="line">class Message {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">char</span> ucMessageID;</div>
<div class="line">  <span class="keywordtype">char</span> ucData[20];</div>
<div class="line">} xMessage;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Queue used to send and receive complete Message objects.</span></div>
<div class="line"><a class="code" href="classFreeRTOS_1_1StaticQueue.html">FreeRTOS::StaticQueue&lt;Message, 10&gt;</a> structQueue;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Queue used to send and receive pointers to Message objects.</span></div>
<div class="line"><a class="code" href="classFreeRTOS_1_1StaticQueue.html">FreeRTOS::StaticQueue&lt;Message*, 10&gt;</a> pointerQueue;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTask::taskFunction() {</div>
<div class="line">  xMessage.ucMessageID = <span class="keyword">static_cast&lt;</span><span class="keywordtype">char</span><span class="keyword">&gt;</span>(0xab);</div>
<div class="line">  std::fill_n(xMessage.ucData, 20, 0x12);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Send the entire object to the queue created to hold 10 objects.</span></div>
<div class="line">  structQueue.<a class="code" href="classFreeRTOS_1_1QueueBase.html#ab38ce516116ed1da212a1197a6bea0c0">sendToBack</a>(xMessage);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Send the address of Message to the queue created to hold 10 pointers.</span></div>
<div class="line">  pointerQueue.<a class="code" href="classFreeRTOS_1_1QueueBase.html#ab38ce516116ed1da212a1197a6bea0c0">sendToBack</a>(&amp;xMessage);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ... Rest of task code goes here.</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyDifferentTask::taskFunction() {</div>
<div class="line">  <span class="comment">// Receive a message from the created queue to hold a Message object.  Block</span></div>
<div class="line">  <span class="comment">// for 10 ticks if a message is not immediately available.  The value is read</span></div>
<div class="line">  <span class="comment">// into a message variable, so after calling receive() message will hold a</span></div>
<div class="line">  <span class="comment">// copy of xMessage.</span></div>
<div class="line">  <span class="keywordflow">if</span> (<span class="keyword">auto</span> message = structQueue.<a class="code" href="classFreeRTOS_1_1QueueBase.html#ae14ed3a5ae6d648b680f85ec9140aed1">receive</a>(10)) {</div>
<div class="line">    <span class="comment">// message now contains a copy of xMessage.</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Receive a message from the created queue to hold pointers.  Block for 10</span></div>
<div class="line">  <span class="comment">// ticks if a message is not immediately available.  The value is read into a</span></div>
<div class="line">  <span class="comment">// pointer variable, and as the value received is the address of the xMessage</span></div>
<div class="line">  <span class="comment">// variable, after this call messagePointer will point to xMessage.</span></div>
<div class="line">  <span class="keywordflow">if</span> (<span class="keyword">auto</span> messagePointer = pointerQueue.<a class="code" href="classFreeRTOS_1_1QueueBase.html#ae14ed3a5ae6d648b680f85ec9140aed1">receive</a>(10)) {</div>
<div class="line">    <span class="comment">// messagePointer now points to xMessage.</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ... Rest of task code goes here.</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ab75dd2a37bfc8488a0b49412f61774dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75dd2a37bfc8488a0b49412f61774dd">&#9670;&nbsp;</a></span>receiveFromISR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;T&gt; <a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::receiveFromISR </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/a00120.html">https://www.freertos.org/a00120.html</a></dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="afaa4ecdebdc7342c205a426ff48b4aec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa4ecdebdc7342c205a426ff48b4aec">&#9670;&nbsp;</a></span>receiveFromISR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt;T&gt; <a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::receiveFromISR </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>higherPriorityTaskWoken</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/a00120.html">https://www.freertos.org/a00120.html</a></dd></dl>
<p>Receive an item from a queue. It is safe to use this function from within an interrupt service routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">higherPriorityTaskWoken</td><td>A reference that will be set to true if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::optional&lt;T&gt; Object from the queue. User should check that the value is present.</dd></dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Kernel.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Queue.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fake interface to send data to.</span></div>
<div class="line"><span class="keywordtype">void</span> sendCharacter(<span class="keywordtype">char</span> c) {}</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> taskFunction() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Queue that holds 10 characters.</span></div>
<div class="line">FreeRTOS::Queue&lt;<span class="keywordtype">char</span>&gt; queue(10);</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTask::taskFunction() {</div>
<div class="line">  constexpr TickType_t ticksToWait = 0xff;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (!queue.isValid()) {</div>
<div class="line">    <span class="comment">// Failed to create the queue.</span></div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Post some characters that will be used within an ISR.  If the queue is full</span></div>
<div class="line">  <span class="comment">// then this task will block for ticksToWait ticks.</span></div>
<div class="line">  queue.sendToBack(<span class="charliteral">&#39;a&#39;</span>, ticksToWait);</div>
<div class="line">  queue.sendToBack(<span class="charliteral">&#39;b&#39;</span>, ticksToWait);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ... keep posting characters ... this task may block when the queue becomes</span></div>
<div class="line">  <span class="comment">// full.</span></div>
<div class="line"> </div>
<div class="line">  queue.sendToBack(<span class="charliteral">&#39;c&#39;</span>, ticksToWait);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ISR that outputs all the characters received on the queue.</span></div>
<div class="line"><span class="keywordtype">void</span> ISR_Routine() {</div>
<div class="line">  <span class="keywordtype">bool</span> taskWokenByReceive = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">while</span> (<span class="keyword">auto</span> character = queue.receiveFromISR(taskWokenByReceive)) {</div>
<div class="line">    <span class="comment">// A character was received.  Output the character now.</span></div>
<div class="line">    sendCharacter(character.value());</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// If removing the character from the queue woke the task that was posting</span></div>
<div class="line">  <span class="comment">// onto the queue taskWokenByReceive will have been set to true.  No matter</span></div>
<div class="line">  <span class="comment">// how many times this loop iterates only one task will be woken.</span></div>
<div class="line">  <span class="keywordflow">if</span> (taskWokenByReceive) {</div>
<div class="line">    <span class="comment">// We should switch context so the ISR returns to a different task.</span></div>
<div class="line">    <span class="comment">// NOTE:  How this is done depends on the port you are using.  Check the</span></div>
<div class="line">    <span class="comment">// documentation and examples for your port.</span></div>
<div class="line">    <a class="code" href="namespaceFreeRTOS_1_1Kernel.html#aa22586993595ea064e411c0063096021">FreeRTOS::Kernel::yield</a>();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4ffb0db014492b760527ed4ba5b352bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ffb0db014492b760527ed4ba5b352bf">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>BaseType_t xQueueReset( QueueHandle_t xQueue )</code> </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/a00018.html#xQueueReset">https://www.freertos.org/a00018.html#xQueueReset</a></dd></dl>
<p>Resets a queue to its original empty state. </p>

</div>
</div>
<a id="ab38ce516116ed1da212a1197a6bea0c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38ce516116ed1da212a1197a6bea0c0">&#9670;&nbsp;</a></span>sendToBack()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::sendToBack </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TickType_t&#160;</td>
          <td class="paramname"><em>ticksToWait</em> = <code>portMAX_DELAY</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait )</code> </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/a00117.html">https://www.freertos.org/a00117.html</a></dd></dl>
<p>Post an item to the back of a queue. The item is queued by copy, not by reference. This function must not be called from an interrupt service routine. See <a class="el" href="classFreeRTOS_1_1QueueBase.html#a02f7119c0502ca70b22d965fa123e4c7" title="Function that calls xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken )">FreeRTOS::Queue::sendToBackFromISR()</a> for an alternative which may be used in an ISR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>A reference to the item that is to be placed on the queue. </td></tr>
    <tr><td class="paramname">ticksToWait</td><td>The maximum amount of time the task should block waiting for space to become available on the queue, should it already be full. The call will return immediately if this is set to 0 and the queue is full. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the item was successfully posted. </td></tr>
    <tr><td class="paramname">false</td><td>otherwise.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Queue.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> taskFunction() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">class Message {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">char</span> ucMessageID;</div>
<div class="line">  <span class="keywordtype">char</span> ucData[20];</div>
<div class="line">} xMessage;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> uint64_t ulVar = 10UL;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTask::taskFunction() {</div>
<div class="line">  <span class="comment">// Create a queue capable of containing 10 unsigned long values.</span></div>
<div class="line">  <a class="code" href="classFreeRTOS_1_1Queue.html">FreeRTOS::Queue&lt;uint64_t&gt;</a> queue1(10);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a queue capable of containing 10 pointers to Message objects.  These</span></div>
<div class="line">  <span class="comment">// should be passed by pointer as they contain a lot of data</span></div>
<div class="line">  <a class="code" href="classFreeRTOS_1_1Queue.html">FreeRTOS::Queue&lt;Message *&gt;</a> queue2(10);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (queue1.isValid()) {</div>
<div class="line">    <span class="comment">// Send an unsigned long.  Wait for 10 ticks for space to become available</span></div>
<div class="line">    <span class="comment">// if necessary.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!queue1.sendToBack(ulVar, 10)) {</div>
<div class="line">      <span class="comment">// Failed to post the message, even after 10 ticks.</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (queue2.isValid()) {</div>
<div class="line">    <span class="comment">// Send a pointer to a Message object.  Don&#39;t block if the queue is already</span></div>
<div class="line">    <span class="comment">// full.</span></div>
<div class="line">    queue2.sendToBack(&amp;xMessage, 0);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Rest of task code.</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a02f7119c0502ca70b22d965fa123e4c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f7119c0502ca70b22d965fa123e4c7">&#9670;&nbsp;</a></span>sendToBackFromISR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::sendToBackFromISR </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>higherPriorityTaskWoken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xQueueSendToBackFromISR.html">https://www.freertos.org/xQueueSendToBackFromISR.html</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">higherPriorityTaskWoken</td><td>A reference that will be set to true if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. </td></tr>
    <tr><td class="paramname">item</td><td>A reference to the item that is to be placed on the queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the item was successfully posted </td></tr>
    <tr><td class="paramname">false</td><td>otherwise.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Kernel.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Queue.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fake interface to get data from.</span></div>
<div class="line"><span class="keywordtype">char</span> getByte() { <span class="keywordflow">return</span> <span class="charliteral">&#39;A&#39;</span>; }</div>
<div class="line"><span class="keywordtype">size_t</span> getBytesRemaining() { <span class="keywordflow">return</span> 0; }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Queue that holds 10 characters.</span></div>
<div class="line"><a class="code" href="classFreeRTOS_1_1StaticQueue.html">FreeRTOS::StaticQueue&lt;char, 10&gt;</a> rxQueue;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> bufferISR() {</div>
<div class="line">  <span class="comment">// We have not woken a task at the start of the ISR.</span></div>
<div class="line">  <span class="keywordtype">bool</span> higherPriorityTaskWoken = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Loop until the buffer is empty.</span></div>
<div class="line">  <span class="keywordflow">do</span> {</div>
<div class="line">    <span class="comment">// Obtain a byte from the buffer and post the byte.</span></div>
<div class="line">    rxQueue.<a class="code" href="classFreeRTOS_1_1QueueBase.html#a02f7119c0502ca70b22d965fa123e4c7">sendToBackFromISR</a>(higherPriorityTaskWoken, getByte());</div>
<div class="line"> </div>
<div class="line">  } <span class="keywordflow">while</span> (getBytesRemaining() &gt; 0);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Now the buffer is empty we can switch context if necessary.</span></div>
<div class="line">  <span class="keywordflow">if</span> (higherPriorityTaskWoken) {</div>
<div class="line">    <a class="code" href="namespaceFreeRTOS_1_1Kernel.html#aa22586993595ea064e411c0063096021">FreeRTOS::Kernel::yield</a>();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a4e82628525bb1fc0737f4fa2af0373cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e82628525bb1fc0737f4fa2af0373cf">&#9670;&nbsp;</a></span>sendToBackFromISR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::sendToBackFromISR </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xQueueSendToBackFromISR.html">https://www.freertos.org/xQueueSendToBackFromISR.html</a></dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="ae1bb5cf497c6e86a186a5e9cf6082c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1bb5cf497c6e86a186a5e9cf6082c55">&#9670;&nbsp;</a></span>sendToFront()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::sendToFront </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TickType_t&#160;</td>
          <td class="paramname"><em>ticksToWait</em> = <code>portMAX_DELAY</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait )</code> </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xQueueSendToFront.html">https://www.freertos.org/xQueueSendToFront.html</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">item</td><td>A reference to the item that is to be placed on the queue. </td></tr>
    <tr><td class="paramname">ticksToWait</td><td>The maximum amount of time the task should block waiting for space to become available on the queue, should it already be full. The call will return immediately if this is set to 0 and the queue is full. The time is defined in tick periods so the constant portTICK_PERIOD_MS should be used to convert to real time if this is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the item was successfully posted. </td></tr>
    <tr><td class="paramname">false</td><td>otherwise.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Queue.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Task.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>MyTask : <span class="keyword">public</span> <a class="code" href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a> {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">void</span> taskFunction() final;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">class Message {</div>
<div class="line"> <span class="keyword">public</span>:</div>
<div class="line">  <span class="keywordtype">char</span> ucMessageID;</div>
<div class="line">  <span class="keywordtype">char</span> ucData[20];</div>
<div class="line">} xMessage;</div>
<div class="line"> </div>
<div class="line">uint64_t ulVar = 10UL;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> MyTask::taskFunction() {</div>
<div class="line">  <span class="comment">// Create a queue capable of containing 10 unsigned long values.</span></div>
<div class="line">  <a class="code" href="classFreeRTOS_1_1Queue.html">FreeRTOS::Queue&lt;uint64_t&gt;</a> queue1(10);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Create a queue capable of containing 10 pointers to Message objects.  These</span></div>
<div class="line">  <span class="comment">// should be passed by pointer as they contain a lot of data</span></div>
<div class="line">  <a class="code" href="classFreeRTOS_1_1Queue.html">FreeRTOS::Queue&lt;Message *&gt;</a> queue2(10);</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (queue1.isValid()) {</div>
<div class="line">    <span class="comment">// Send an unsigned long.  Wait for 10 ticks for space to become available</span></div>
<div class="line">    <span class="comment">// if necessary.</span></div>
<div class="line">    <span class="keywordflow">if</span> (!queue1.sendToFront(ulVar, 10)) {</div>
<div class="line">      <span class="comment">// Failed to post the message, even after 10 ticks.</span></div>
<div class="line">    }</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (queue2.isValid()) {</div>
<div class="line">    <span class="comment">// Send a pointer to a Message object.  Don&#39;t block if the queue is already</span></div>
<div class="line">    <span class="comment">// full.</span></div>
<div class="line">    queue2.sendToFront(&amp;xMessage, 0);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Rest of task code.</span></div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ad1ef1f391f1728466f678e4bf3882386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ef1f391f1728466f678e4bf3882386">&#9670;&nbsp;</a></span>sendToFrontFromISR() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::sendToFrontFromISR </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>higherPriorityTaskWoken</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>xQueueSendToFrontFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xQueueSendToFrontFromISR.html">https://www.freertos.org/xQueueSendToFrontFromISR.html</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">higherPriorityTaskWoken</td><td>A reference that will be set to true if sending to the queue caused a task to unblock, and the unblocked task has a priority higher than the currently running task. </td></tr>
    <tr><td class="paramname">item</td><td>A reference to the item that is to be placed on the queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the item was successfully posted </td></tr>
    <tr><td class="paramname">false</td><td>otherwise.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Example Usage</b> </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Kernel.hpp&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;FreeRTOS/Queue.hpp&gt;</span></div>
<div class="line"> </div>
<div class="line">constexpr <span class="keywordtype">char</span> emergencyMessage = <span class="charliteral">&#39;E&#39;</span>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Fake interface to get data from.</span></div>
<div class="line"><span class="keywordtype">char</span> getByte() { <span class="keywordflow">return</span> <span class="charliteral">&#39;A&#39;</span>; }</div>
<div class="line"><span class="keywordtype">size_t</span> getBytesRemaining() { <span class="keywordflow">return</span> 0; }</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Queue that holds 10 characters.</span></div>
<div class="line"><a class="code" href="classFreeRTOS_1_1StaticQueue.html">FreeRTOS::StaticQueue&lt;char, 10&gt;</a> rxQueue;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> bufferISR() {</div>
<div class="line">  <span class="comment">// We have not woken a task at the start of the ISR.</span></div>
<div class="line">  <span class="keywordtype">bool</span> higherPriorityTaskWoken = <span class="keyword">false</span>;</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Obtain a byte from the buffer.</span></div>
<div class="line">  <span class="keywordtype">char</span> cIn = getByte();</div>
<div class="line"> </div>
<div class="line">  <span class="keywordflow">if</span> (cIn == emergencyMessage) {</div>
<div class="line">    <span class="comment">// Post the byte to the front of the queue.</span></div>
<div class="line">    rxQueue.<a class="code" href="classFreeRTOS_1_1QueueBase.html#ad1ef1f391f1728466f678e4bf3882386">sendToFrontFromISR</a>(higherPriorityTaskWoken, cIn);</div>
<div class="line">  } <span class="keywordflow">else</span> {</div>
<div class="line">    <span class="comment">// Post the byte to the back of the queue.</span></div>
<div class="line">    rxQueue.<a class="code" href="classFreeRTOS_1_1QueueBase.html#a02f7119c0502ca70b22d965fa123e4c7">sendToBackFromISR</a>(higherPriorityTaskWoken, cIn);</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  <span class="comment">// Did sending to the queue unblock a higher priority task?</span></div>
<div class="line">  <span class="keywordflow">if</span> (higherPriorityTaskWoken) {</div>
<div class="line">    <a class="code" href="namespaceFreeRTOS_1_1Kernel.html#aa22586993595ea064e411c0063096021">FreeRTOS::Kernel::yield</a>();</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --> 
</div>
</div>
<a id="a2781f1630fb21528e20b60b5ab052c1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2781f1630fb21528e20b60b5ab052c1e">&#9670;&nbsp;</a></span>sendToFrontFromISR() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::sendToFrontFromISR </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>xQueueSendToFrontFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken )</code> </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/xQueueSendToFrontFromISR.html">https://www.freertos.org/xQueueSendToFrontFromISR.html</a></dd></dl>
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a8d5f96189286ba25eb9d937f531632e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d5f96189286ba25eb9d937f531632e5">&#9670;&nbsp;</a></span>spacesAvailable()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UBaseType_t <a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::spacesAvailable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>UBaseType_t uxQueueSpacesAvailable( QueueHandle_t xQueue )</code> </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/a00018.html#uxQueueSpacesAvailable">https://www.freertos.org/a00018.html#uxQueueSpacesAvailable</a></dd></dl>
<p>Return the number of free spaces in a queue.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">UBaseType_t</td><td>The number of free spaces available in the queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa51ec0de8264da31fdaa6b348694024e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51ec0de8264da31fdaa6b348694024e">&#9670;&nbsp;</a></span>unregister()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFreeRTOS_1_1QueueBase.html">FreeRTOS::QueueBase</a>&lt; T &gt;::unregister </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Function that calls <code>void vQueueUnregisterQueue( QueueHandle_t xQueue )</code> </p>
<p><a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></p>
<dl class="section see"><dt>See also</dt><dd><a href="https://www.freertos.org/vQueueUnregisterQueue.html">https://www.freertos.org/vQueueUnregisterQueue.html</a></dd></dl>
<p>The registry is provided as a means for kernel aware debuggers to locate queues, semaphores and mutexes. Call <a class="el" href="classFreeRTOS_1_1QueueBase.html#aa2ce0f34fcc0ccc84c3898dd6f28fd02" title="Function that calls void vQueueAddToRegistry( QueueHandle_t xQueue, char *pcQueueName )">addToRegistry()</a> add a queue, semaphore or mutex handle to the registry if you want the handle to be available to a kernel aware debugger, and <a class="el" href="classFreeRTOS_1_1QueueBase.html#aa51ec0de8264da31fdaa6b348694024e" title="Function that calls void vQueueUnregisterQueue( QueueHandle_t xQueue )">unregister()</a> to remove the queue, semaphore or mutex from the register. If you are not using a kernel aware debugger then this function can be ignored. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/runner/work/FreeRTOS-Cpp/FreeRTOS-Cpp/FreeRTOS-Cpp/include/FreeRTOS/<a class="el" href="Queue_8hpp_source.html">Queue.hpp</a></li>
</ul>
</div><!-- contents -->
<div class="ttc" id="aclassFreeRTOS_1_1QueueBase_html_ad1ef1f391f1728466f678e4bf3882386"><div class="ttname"><a href="classFreeRTOS_1_1QueueBase.html#ad1ef1f391f1728466f678e4bf3882386">FreeRTOS::QueueBase::sendToFrontFromISR</a></div><div class="ttdeci">bool sendToFrontFromISR(bool &amp;higherPriorityTaskWoken, const T &amp;item) const</div><div class="ttdoc">Function that calls xQueueSendToFrontFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken )</div><div class="ttdef"><b>Definition:</b> Queue.hpp:195</div></div>
<div class="ttc" id="aclassFreeRTOS_1_1QueueBase_html_a02f7119c0502ca70b22d965fa123e4c7"><div class="ttname"><a href="classFreeRTOS_1_1QueueBase.html#a02f7119c0502ca70b22d965fa123e4c7">FreeRTOS::QueueBase::sendToBackFromISR</a></div><div class="ttdeci">bool sendToBackFromISR(bool &amp;higherPriorityTaskWoken, const T &amp;item) const</div><div class="ttdoc">Function that calls xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken )</div><div class="ttdef"><b>Definition:</b> Queue.hpp:127</div></div>
<div class="ttc" id="aclassFreeRTOS_1_1QueueBase_html_a39366d8cd04e9d8d08ec887564fecbbe"><div class="ttname"><a href="classFreeRTOS_1_1QueueBase.html#a39366d8cd04e9d8d08ec887564fecbbe">FreeRTOS::QueueBase::overwriteFromISR</a></div><div class="ttdeci">void overwriteFromISR(bool &amp;higherPriorityTaskWoken, const T &amp;item) const</div><div class="ttdoc">Function that calls BaseType_t xQueueOverwriteFromISR( QueueHandle_t xQueue, const void * pvItemToQue...</div><div class="ttdef"><b>Definition:</b> Queue.hpp:412</div></div>
<div class="ttc" id="aclassFreeRTOS_1_1QueueBase_html_a9871e7011ac00cf50e12cbf4a41d2201"><div class="ttname"><a href="classFreeRTOS_1_1QueueBase.html#a9871e7011ac00cf50e12cbf4a41d2201">FreeRTOS::QueueBase::peek</a></div><div class="ttdeci">std::optional&lt; T &gt; peek(const TickType_t ticksToWait=portMAX_DELAY) const</div><div class="ttdoc">Function that calls BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer,...</div><div class="ttdef"><b>Definition:</b> Queue.hpp:465</div></div>
<div class="ttc" id="aclassFreeRTOS_1_1Queue_html"><div class="ttname"><a href="classFreeRTOS_1_1Queue.html">FreeRTOS::Queue</a></div><div class="ttdoc">Class that encapsulates the functionality of a FreeRTOS queue.</div><div class="ttdef"><b>Definition:</b> Queue.hpp:639</div></div>
<div class="ttc" id="aclassFreeRTOS_1_1Task_html"><div class="ttname"><a href="classFreeRTOS_1_1Task.html">FreeRTOS::Task</a></div><div class="ttdoc">Class that encapsulates the functionality of a FreeRTOS task.</div><div class="ttdef"><b>Definition:</b> Task.hpp:1291</div></div>
<div class="ttc" id="aclassFreeRTOS_1_1QueueBase_html_ae14ed3a5ae6d648b680f85ec9140aed1"><div class="ttname"><a href="classFreeRTOS_1_1QueueBase.html#ae14ed3a5ae6d648b680f85ec9140aed1">FreeRTOS::QueueBase::receive</a></div><div class="ttdeci">std::optional&lt; T &gt; receive(const TickType_t ticksToWait=portMAX_DELAY) const</div><div class="ttdoc">Function that calls BaseType_t xQueueReceive( QueueHandle_t xQueue, void *pvBuffer,...</div><div class="ttdef"><b>Definition:</b> Queue.hpp:244</div></div>
<div class="ttc" id="aclassFreeRTOS_1_1StaticQueue_html"><div class="ttname"><a href="classFreeRTOS_1_1StaticQueue.html">FreeRTOS::StaticQueue</a></div><div class="ttdoc">Class that encapsulates the functionality of a FreeRTOS queue.</div><div class="ttdef"><b>Definition:</b> Queue.hpp:700</div></div>
<div class="ttc" id="aclassFreeRTOS_1_1QueueBase_html_ab38ce516116ed1da212a1197a6bea0c0"><div class="ttname"><a href="classFreeRTOS_1_1QueueBase.html#ab38ce516116ed1da212a1197a6bea0c0">FreeRTOS::QueueBase::sendToBack</a></div><div class="ttdeci">bool sendToBack(const T &amp;item, const TickType_t ticksToWait=portMAX_DELAY) const</div><div class="ttdoc">Function that calls xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait )</div><div class="ttdef"><b>Definition:</b> Queue.hpp:104</div></div>
<div class="ttc" id="anamespaceFreeRTOS_1_1Kernel_html_aa22586993595ea064e411c0063096021"><div class="ttname"><a href="namespaceFreeRTOS_1_1Kernel.html#aa22586993595ea064e411c0063096021">FreeRTOS::Kernel::yield</a></div><div class="ttdeci">void yield()</div><div class="ttdoc">Function that calls taskYIELD()</div><div class="ttdef"><b>Definition:</b> Kernel.hpp:153</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
